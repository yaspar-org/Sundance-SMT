(declare-const x42 Bool)
(declare-sort F 0)
(declare-fun u (F) F)
(declare-sort P 0)
(declare-fun I (Int) P)
(declare-sort T 0)
(declare-sort D 0)
(declare-const $ D)
(declare-fun h (P T) Bool)
(declare-fun S (Int Int) Int)
(declare-sort vst 0)
(declare-sort vs 0)
(declare-datatypes ((x42 0) (lib!betree.PivotBranchRefinement_v.AppendLabel. 0) (lib!betree.PivotBranchRefinement_v.InternalLabel. 0) (lib!betree.PivotBranch_v.SplitArg. 0) (lib!betree.PivotBranch_v.Node. 0) (lib!betree.PivotBranch_v.Path. 0) (lib!spec.KeyType_t.Key. 0) (lib!spec.Messages_t.Value. 0) (lib!spec.Messages_t.Delta. 0) (lib!spec.Messages_t.Message. 0) (tuple%0. 0) (tuple%2. 0)) (((lib!betree.PivotBranchRefinement_v.InsertLabel./InsertLabel (lib!betree.PivotBranchRefinement_v.InsertLabel./InsertLabel/?key lib!spec.KeyType_t.Key.) (lib!betree.PivotBranchRefinement_v.InsertLabel./InsertLabel/?msg lib!spec.Messages_t.Message.) (lib!betree.PivotBranchRefinement_v.InsertLabel./InsertLabel/?path lib!betree.PivotBranch_v.Path.))) ((lib!betree.PivotBranchRefinement_v.AppendLabel./AppendLabel (lib!betree.PivotBranchRefinement_v.AppendLabel./AppendLabel/?keys vst) (lib!betree.PivotBranchRefinement_v.AppendLabel./AppendLabel/?msgs vs) (lib!betree.PivotBranchRefinement_v.AppendLabel./AppendLabel/?path lib!betree.PivotBranch_v.Path.))) ((lib!betree.PivotBranchRefinement_v.InternalLabel./InternalLabel)) ((lib!betree.PivotBranch_v.SplitArg./SplitIndex (lib!betree.PivotBranch_v.SplitArg./SplitIndex/?pivot lib!spec.KeyType_t.Key.) (lib!betree.PivotBranch_v.SplitArg./SplitIndex/?pivot_index Int))) ((lib!betree.PivotBranch_v.Node./Leaf (lib!betree.PivotBranch_v.Node./Leaf/?keys vst) (lib!betree.PivotBranch_v.Node./Leaf/?msgs vs))) ((lib!betree.PivotBranch_v.Path./Path (lib!betree.PivotBranch_v.Path./Path/?node lib!betree.PivotBranch_v.Node.) (lib!betree.PivotBranch_v.Path./Path/?key lib!spec.KeyType_t.Key.) (lib!betree.PivotBranch_v.Path./Path/?depth Int))) ((lib!spec.KeyType_t.Key./Key (lib!spec.KeyType_t.Key./Key/?0 Int))) ((lib!spec.Messages_t.Value./Value (lib!spec.Messages_t.Value./Value/?0 Int))) ((lib!spec.Messages_t.Delta./Delta (lib!spec.Messages_t.Delta./Delta/?0 Int))) ((lib!spec.Messages_t.Message./Define (lib!spec.Messages_t.Message./Define/?value lib!spec.Messages_t.Value.)) (lib!spec.Messages_t.Message./Update (lib!spec.Messages_t.Message./Update/?delta lib!spec.Messages_t.Delta.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 vs) (tuple%2./tuple%2/?1 vs)))))
(declare-fun ib! (lib!betree.PivotBranch_v.Node.) vst)
(declare-const T T)
(declare-fun P (vst) P)
(declare-fun o (lib!betree.PivotBranch_v.Node.) P)
(declare-fun % (P) lib!betree.PivotBranch_v.Node.)
(declare-fun Po (lib!spec.KeyType_t.Key.) P)
(declare-fun vst (D T P) Int)
(declare-fun vs (D T P P) P)
(declare-fun ib (P P) Bool)
(declare-fun l (P) Bool)
(declare-fun li (P F) Bool)
(declare-fun lib (P) vst)
(declare-fun lib! (P P) Int)
(declare-fun lib!s (P P F) Int)
(declare-fun lib!betre (P P) Int)
(assert (forall ((a P) (b P)) (! (= (ib a b) (not (= a b))) :pattern ((ib a b)))))
(assert (forall ((r P)) (! (= (l r) (forall ((i P) (j P)) (! (ib (vs $ T r j) (vs $ T r j)) :pattern ((vs $ T r j))))) :pattern ((l r)))))
(assert (forall ((e P) (ue F)) (! (= (li e (u ue)) (l (P (ib! (% e))))) :pattern ((u ue)))))
(declare-const fue F)
(assert (forall ((r P) (e P) (ue F)) (! (= (lib!s r r (u ue)) (ite (ib e (vs $ T r (I 0))) (S 0 1) (lib!s (I 1) r ue))) :pattern ((lib!s r e (u ue))))))
(assert (forall ((r P) (e P)) (! (= (lib! r r) (lib!s r e (u fue))) :pattern ((lib! r e)))))
(assert (forall ((e P) (k P)) (! (= (lib! e e) (lib! k (P (ite ((_ is lib!betree.PivotBranch_v.Node./Leaf) (% k)) (ib! (% k)) (ib! (% k)))))) :pattern ((lib!betre e k)))))
(assert (forall ((e P) (k P)) (! (or x42 (and (= (P (lib e)) k) (forall ((i P)) (! (=> (h i T) (ib k (P (lib e)))) :pattern ((lib i)))))) :pattern ((lib!betre e k)))))
(declare-const n lib!betree.PivotBranch_v.Node.)
(declare-const k lib!spec.KeyType_t.Key.)
(declare-const s vst)
(assert (and (not (ib (Po k) (P s))) (= (lib!betre (o n) (Po k)) (vst $ T (P (lib (o n)))))))
