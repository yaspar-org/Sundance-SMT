(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :pi.enabled false)
(set-option :rewriter.sort_disjunctions false)
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
;(assert (=> true (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) ))))
(declare-sort Poly 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun has_type (Poly Type) Bool)
(declare-fun sized (Dcr) Bool)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(assert (sized $))
;(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((B b)) )))
;(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)) )))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)) )))
;(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)) )))
;(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)) )))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(declare-const fuel%vstd!set.axiom_set_new. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%set_relations!is_member. FuelId)
(declare-const fuel%set_relations!set_union. FuelId)
(declare-const fuel%set_relations!set_intersection. FuelId)
(declare-const fuel%set_relations!set_difference. FuelId)
(declare-const fuel%set_relations!is_subset. FuelId)
(declare-const fuel%set_relations!is_equal. FuelId)
(declare-const fuel%set_relations!empty_set. FuelId)
(declare-const fuel%set_relations!universal_set. FuelId)
(declare-const fuel%set_relations!singleton. FuelId)
(declare-const fuel%set_relations!is_empty. FuelId)
(declare-const fuel%set_relations!is_singleton. FuelId)
(declare-const fuel%set_relations!is_at_most_one. FuelId)
(declare-const fuel%set_relations!are_disjoint. FuelId)
(declare-const fuel%set_relations!have_overlap. FuelId)
(declare-const fuel%set_relations!red_colors. FuelId)
(declare-const fuel%set_relations!primary_colors. FuelId)
(declare-const fuel%set_relations!warm_colors. FuelId)
(declare-const fuel%set_relations!round_shapes. FuelId)
(declare-const fuel%set_relations!angular_shapes. FuelId)
(declare-const fuel%set_relations!non_red_colors. FuelId)
(declare-const fuel%set_relations!non_circle_shapes. FuelId)
(declare-const fuel%set_relations!complement. FuelId)
(declare-const fuel%set_relations!forms_partition. FuelId)
(declare-sort vstd!set.Set<set_relations!Color.>. 0)
(declare-sort vstd!set.Set<set_relations!Shape.>. 0)
(declare-datatypes ((set_relations!Color. 0) (set_relations!Shape. 0) (tuple%0. 0)) (((set_relations!Color./Red) (set_relations!Color./Green) (set_relations!Color./Blue)) ((set_relations!Shape./Circle) (set_relations!Shape./Square) (set_relations!Shape./Triangle)) ((tuple%0./tuple%0))))
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%set_relations!Color. Type)
(declare-const TYPE%set_relations!Shape. Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!set.Set<set_relations!Color.>. (vstd!set.Set<set_relations!Color.>.) Poly)
(declare-fun %Poly%vstd!set.Set<set_relations!Color.>. (Poly) vstd!set.Set<set_relations!Color.>.)
(declare-fun %Poly%vstd!set.Set<set_relations!Shape.>. (Poly) vstd!set.Set<set_relations!Shape.>.)
(declare-fun Poly%set_relations!Color. (set_relations!Color.) Poly)
(declare-fun %Poly%set_relations!Color. (Poly) set_relations!Color.)
;(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)) )))
;(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x Poly)) (! (=> (has_type x (TYPE%fun%1. T%1&. TYPE%set_relations!Color. T%1&. T%1&)) (= x (Poly%fun%1. (%Poly%fun%1. x)))) :pattern ((has_type x (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
;(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 TYPE%set_relations!Color.) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)) )) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%1&. TYPE%set_relations!Color. T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
;(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0 Poly) (x %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x) (TYPE%fun%1. T%1&. TYPE%set_relations!Color. T%1&. T%1&)) (has_type T%0 TYPE%set_relations!Color.)) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((%%apply%%0 x T%0) (has_type (Poly%fun%1. x) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) )))
;(assert (forall ((x vstd!set.Set<set_relations!Color.>.)) (! (= x (%Poly%vstd!set.Set<set_relations!Color.>. (Poly%vstd!set.Set<set_relations!Color.>. x))) :pattern ((Poly%vstd!set.Set<set_relations!Color.>. x)) )))
;(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.)) (= x (Poly%vstd!set.Set<set_relations!Color.>. (%Poly%vstd!set.Set<set_relations!Color.>. x)))) :pattern ((has_type x (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.))) )))
;(assert (forall ((x vstd!set.Set<set_relations!Color.>.)) (! (has_type (Poly%vstd!set.Set<set_relations!Color.>. x) (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.)) :pattern ((has_type (Poly%vstd!set.Set<set_relations!Color.>. x) (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.))) )))
(assert (forall ((x set_relations!Color.)) (! (= x (%Poly%set_relations!Color. (Poly%set_relations!Color. x))) :pattern ((Poly%set_relations!Color. x)) )))
;(assert (forall ((x Poly)) (! (=> (has_type x TYPE%set_relations!Color.) (= x (Poly%set_relations!Color. (%Poly%set_relations!Color. x)))) :pattern ((has_type x TYPE%set_relations!Color.)) )))
;(assert (forall ((x set_relations!Color.)) (! (has_type (Poly%set_relations!Color. x) TYPE%set_relations!Color.) :pattern ((has_type (Poly%set_relations!Color. x) TYPE%set_relations!Color.)) )))
(declare-fun vstd!set.Set.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Poly) Poly)
(declare-fun set_relations!is_member.? (Dcr Type Poly Poly) Bool)
(declare-fun set_relations!set_union.? (Dcr Type Poly Poly) Poly)
(declare-fun set_relations!set_intersection.? (Dcr Type Poly Poly) Poly)
(declare-fun set_relations!set_difference.? (Dcr Type Poly Poly) Poly)
(declare-fun set_relations!is_subset.? (Dcr Type Poly Poly) Bool)
(declare-fun set_relations!is_equal.? (Dcr Type Poly Poly) Bool)
(declare-fun set_relations!empty_set.? (Dcr Type) Poly)
(declare-fun set_relations!universal_set.? (Dcr Type) Poly)
(declare-fun set_relations!singleton.? (Dcr Type Poly) Poly)
(declare-fun set_relations!is_empty.? (Dcr Type Poly) Bool)
(declare-fun set_relations!is_singleton.? (Dcr Type Poly) Bool)
(declare-fun set_relations!is_at_most_one.? (Dcr Type Poly) Bool)
(declare-fun set_relations!are_disjoint.? (Dcr Type Poly Poly) Bool)
(declare-fun set_relations!have_overlap.? (Dcr Type Poly Poly) Bool)
(declare-fun set_relations!red_colors.? (Poly) vstd!set.Set<set_relations!Color.>.)
(declare-fun set_relations!primary_colors.? (Poly) vstd!set.Set<set_relations!Color.>.)
(declare-fun set_relations!warm_colors.? (Poly) vstd!set.Set<set_relations!Color.>.)
(declare-fun set_relations!round_shapes.? (Poly) vstd!set.Set<set_relations!Shape.>.)
(declare-fun set_relations!angular_shapes.? (Poly) vstd!set.Set<set_relations!Shape.>.)
(declare-fun set_relations!non_red_colors.? (Poly) vstd!set.Set<set_relations!Color.>.)
(declare-fun set_relations!non_circle_shapes.? (Poly) vstd!set.Set<set_relations!Shape.>.)
(declare-fun set_relations!complement.? (Dcr Type Poly Poly) Poly)
(declare-fun set_relations!forms_partition.? (Dcr Type Poly Poly Poly) Bool)
;(assert (forall ((A&. Dcr) (A& Type) (f! Poly)) (! (=> (has_type f! (TYPE%fun%1. A&. A& $ BOOL)) (has_type (vstd!set.impl&%0.new.? A&. A& f!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.new.? A&. A& f!)) )))
;(assert (=> (fuel_bool fuel%vstd!set.axiom_set_new.) (forall ((A&. Dcr) (A& Type) (f! Poly) (a! Poly)) (! (=> (and (has_type f! (TYPE%fun%1. A&. A& $ BOOL)) (has_type a! A&)) (=> (sized A&.) (= (vstd!set.Set.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& f!) a!) (%B (%%apply%%0 (%Poly%fun%1. f!) a!))))) :pattern ((vstd!set.Set.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& f!) a!)) ))))
;(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
;(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal_deep.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1! s2!)) ))))
;(assert (fuel_bool_default fuel%set_relations!is_member.))
;(assert (=> (fuel_bool fuel%set_relations!is_member.) (forall ((T&. Dcr) (T& Type) (x! Poly) (set! Poly)) (! (= (set_relations!is_member.? T&. T& x! set!) (vstd!set.Set.contains.? T&. T& set! x!)) :pattern ((set_relations!is_member.? T&. T& x! set!)) ))))
(declare-fun %%lambda%%0 (Dcr Type Poly Dcr Type Poly) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!set_union.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!set_union.? T&. T& s1! s2!)) ))))
(declare-fun %%lambda%%1 (Dcr Type Poly Dcr Type Poly) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!set_intersection.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!set_intersection.? T&. T& s1! s2!)) ))))
(declare-fun %%lambda%%2 (Dcr Type Poly Dcr Type Poly) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!set_difference.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!set_difference.? T&. T& s1! s2!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!is_subset.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!is_subset.? T&. T& s1! s2!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!is_equal.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!is_equal.? T&. T& s1! s2!)) ))))
(declare-fun %%lambda%%3 (Poly) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!empty_set.) (forall ((T&. Dcr) (T& Type)) (! false :pattern ((set_relations!empty_set.? T&. T&)) ))))
;(assert (=> (fuel_bool fuel%set_relations!universal_set.) (forall ((T&. Dcr) (T& Type)) (! false :pattern ((set_relations!universal_set.? T&. T&)) ))))
(declare-fun %%lambda%%4 (Poly) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!singleton.) (forall ((T&. Dcr) (T& Type) (x! Poly)) (! false :pattern ((set_relations!singleton.? T&. T& x!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!is_empty.) (forall ((T&. Dcr) (T& Type) (s! Poly)) (! false :pattern ((set_relations!is_empty.? T&. T& s!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!is_singleton.) (forall ((T&. Dcr) (T& Type) (s! Poly)) (! false :pattern ((set_relations!is_singleton.? T&. T& s!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!is_at_most_one.) (forall ((T&. Dcr) (T& Type) (s! Poly)) (! false :pattern ((set_relations!is_at_most_one.? T&. T& s!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!are_disjoint.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!are_disjoint.? T&. T& s1! s2!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!have_overlap.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly)) (! false :pattern ((set_relations!have_overlap.? T&. T& s1! s2!)) ))))
(declare-fun %%lambda%%5 (set_relations!Color.) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!red_colors.) (forall ((no%param Poly)) (! false :pattern ((set_relations!red_colors.? no%param)) ))))
;(assert (fuel_bool_default fuel%set_relations!primary_colors.))
(declare-fun %%lambda%%6 (set_relations!Color. set_relations!Color.) %%Function%%)
(assert (forall ((%%hole%%0 set_relations!Color.) (%%hole%%1 set_relations!Color.) (c$ Poly)) (! (= (%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) c$) (B (or (= (%Poly%set_relations!Color. c$) set_relations!Color./Red) (= (%Poly%set_relations!Color. c$) set_relations!Color./Blue)))) :pattern ((%%apply%%0 (%%lambda%%6 %%hole%%0 %%hole%%1) c$)))))
;(assert (=> (fuel_bool fuel%set_relations!primary_colors.) (forall ((no%param Poly)) (! (= (set_relations!primary_colors.? no%param) (%Poly%vstd!set.Set<set_relations!Color.>. (vstd!set.impl&%0.new.? $ TYPE%set_relations!Color. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))))) :pattern ((set_relations!primary_colors.? no%param)) ))))
;(assert (=> (fuel_bool fuel%set_relations!warm_colors.) (forall ((no%param Poly)) (! false :pattern ((set_relations!warm_colors.? no%param)) ))))
(declare-fun %%lambda%%7 (set_relations!Shape.) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!round_shapes.) (forall ((no%param Poly)) (! false :pattern ((set_relations!round_shapes.? no%param)) ))))
(declare-fun %%lambda%%8 (set_relations!Shape. set_relations!Shape.) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!angular_shapes.) (forall ((no%param Poly)) (! false :pattern ((set_relations!angular_shapes.? no%param)) ))))
(declare-fun %%lambda%%9 (set_relations!Color.) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!non_red_colors.) (forall ((no%param Poly)) (! false :pattern ((set_relations!non_red_colors.? no%param)) ))))
(declare-fun %%lambda%%10 (set_relations!Shape.) %%Function%%)
;(assert (=> (fuel_bool fuel%set_relations!non_circle_shapes.) (forall ((no%param Poly)) (! false :pattern ((set_relations!non_circle_shapes.? no%param)) ))))
;(assert (=> (fuel_bool fuel%set_relations!complement.) (forall ((T&. Dcr) (T& Type) (s! Poly) (universe! Poly)) (! false :pattern ((set_relations!complement.? T&. T& s! universe!)) ))))
;(assert (=> (fuel_bool fuel%set_relations!forms_partition.) (forall ((T&. Dcr) (T& Type) (s1! Poly) (s2! Poly) (universe! Poly)) (! false :pattern ((set_relations!forms_partition.? T&. T& s1! s2! universe!)) ))))
;(assert true)
(declare-const %%location_label%%0 Bool)
(declare-const !!skolem_variable_0 Poly)
;(assert (not (not (set_relations!is_member.? $ TYPE%set_relations!Color. (Poly%set_relations!Color. set_relations!Color./Green) (Poly%vstd!set.Set<set_relations!Color.>. (set_relations!primary_colors.? (I 0)))))))
;(assert (= (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue))) (Poly%fun%1. (%Poly%fun%1. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))))))
;(assert (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 TYPE%set_relations!Color.) (has_type (%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) T%0) BOOL)) :pattern ((%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) T%0)))) (has_type (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue))) (TYPE%fun%1. $ TYPE%set_relations!Color. $ BOOL))))
;(assert (=> (has_type (vstd!set.impl&%0.new.? $ TYPE%set_relations!Color. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))) (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.)) (= (vstd!set.impl&%0.new.? $ TYPE%set_relations!Color. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))) (Poly%vstd!set.Set<set_relations!Color.>. (%Poly%vstd!set.Set<set_relations!Color.>. (vstd!set.impl&%0.new.? $ TYPE%set_relations!Color. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))))))))
;(assert (=> (has_type !!skolem_variable_0 TYPE%set_relations!Color.) (= !!skolem_variable_0 (Poly%set_relations!Color. (%Poly%set_relations!Color. !!skolem_variable_0)))))
;(assert (has_type (B (or (= (%Poly%set_relations!Color. !!skolem_variable_0) set_relations!Color./Red) (= (%Poly%set_relations!Color. !!skolem_variable_0) set_relations!Color./Blue))) BOOL))
;(assert (= (%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) !!skolem_variable_0) (B (%B (%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) !!skolem_variable_0)))))
;(assert (has_type (Poly%vstd!set.Set<set_relations!Color.>. (set_relations!primary_colors.? (I 0))) (TYPE%vstd!set.Set. $ TYPE%set_relations!Color.)))
;(assert (=> (and (has_type (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue))) (TYPE%fun%1. $ TYPE%set_relations!Color. $ BOOL)) (has_type (Poly%set_relations!Color. set_relations!Color./Green) TYPE%set_relations!Color.)) (= (vstd!set.Set.contains.? $ TYPE%set_relations!Color. (vstd!set.impl&%0.new.? $ TYPE%set_relations!Color. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))) (Poly%set_relations!Color. set_relations!Color./Green)) (%B (%%apply%%0 (%Poly%fun%1. (Poly%fun%1. (mk_fun (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue)))) (Poly%set_relations!Color. set_relations!Color./Green))))))
(assert (= (%%apply%%0 (%%lambda%%6 set_relations!Color./Red set_relations!Color./Blue) (Poly%set_relations!Color. set_relations!Color./Green)) (B true)))
(check-sat)
