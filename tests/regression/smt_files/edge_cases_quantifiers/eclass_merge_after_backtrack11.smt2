(declare-sort FuelId 0)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)))))
(declare-sort Poly 0)
(declare-fun I (Int) Poly)
(declare-fun %I (Poly) Int)
(declare-sort Type 0)
(declare-const NAT Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun has_type (Poly Type) Bool)
;(assert (forall ((x Poly)) (! true :pattern ((has_type x NAT)))))
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%0.wf. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%0.valid_child_index. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%0.occupied_child_index. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%1.entries_wf. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%1.wf. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%1.get. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%5.wf. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%5.has_root. FuelId)
(declare-const fuel%lib!betree.LinkedBetree_v.impl&%5.root. FuelId)
(declare-sort vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. 0)
(declare-sort vstd!map.Map<lib!spec.KeyType_t.Key./nat.>. 0)
(declare-sort vstd!map.Map<lib!spec.KeyType_t.Key./lib!spec.Messages_t.Message.>. 0)
(declare-sort vstd!raw_ptr.DynMetadata. 0)
(declare-sort vstd!raw_ptr.Provenance. 0)
(declare-sort vstd!seq.Seq<nat.>. 0)
(declare-sort vstd!seq.Seq<core!option.Option<lib!spec.AsyncDisk_t.Address.>.>. 0)
(declare-sort vstd!seq.Seq<lib!spec.AsyncDisk_t.Address.>. 0)
(declare-sort vstd!seq.Seq<lib!spec.KeyType_t.Element.>. 0)
(declare-datatypes ((core!option.Option. 0) (vstd!raw_ptr.Metadata. 0) (vstd!raw_ptr.PtrData. 0) (lib!abstract_system.StampedMap_v.Stamped. 0) (lib!betree.BufferDisk_v.BufferDisk. 0) (lib!betree.BufferOffsets_v.BufferOffsets. 0) (lib!betree.Buffer_v.SimpleBuffer. 0) (lib!betree.Domain_v.Domain. 0) (lib!betree.LinkedBetree_v.BetreeNode. 0) (lib!betree.LinkedBetree_v.DiskView. 0) (lib!betree.LinkedBetree_v.TwoAddrs. 0) (lib!betree.LinkedBetree_v.SplitAddrs. 0) (lib!betree.LinkedBetree_v.LinkedBetree. 0) (lib!betree.LinkedBetree_v.QueryReceiptLine. 0) (lib!betree.LinkedBetree_v.QueryReceipt. 0) (lib!betree.LinkedBetree_v.Path. 0) (lib!betree.LinkedSeq_v.LinkedSeq. 0) (lib!betree.Memtable_v.Memtable. 0) (lib!betree.OffsetMap_v.OffsetMap. 0) (lib!betree.PivotTable_v.PivotTable. 0) (lib!betree.SplitRequest_v.SplitRequest. 0) (lib!spec.AsyncDisk_t.Address. 0) (lib!spec.KeyType_t.Key. 0) (lib!spec.KeyType_t.Element. 0) (lib!spec.Messages_t.Value. 0) (lib!spec.Messages_t.Delta. 0) (lib!spec.Messages_t.Message. 0) (tuple%0. 0) (tuple%2. 0)) (((core!option.Option./None) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((vstd!raw_ptr.Metadata./Thin) (vstd!raw_ptr.Metadata./Length (vstd!raw_ptr.Metadata./Length/?0 Int)) (vstd!raw_ptr.Metadata./Dyn (vstd!raw_ptr.Metadata./Dyn/?0 vstd!raw_ptr.DynMetadata.))) ((vstd!raw_ptr.PtrData./PtrData (vstd!raw_ptr.PtrData./PtrData/?addr Int) (vstd!raw_ptr.PtrData./PtrData/?provenance vstd!raw_ptr.Provenance.) (vstd!raw_ptr.PtrData./PtrData/?metadata vstd!raw_ptr.Metadata.))) ((lib!abstract_system.StampedMap_v.Stamped./Stamped (lib!abstract_system.StampedMap_v.Stamped./Stamped/?value Poly) (lib!abstract_system.StampedMap_v.Stamped./Stamped/?seq_end Int))) ((lib!betree.BufferDisk_v.BufferDisk./BufferDisk (lib!betree.BufferDisk_v.BufferDisk./BufferDisk/?entries Poly))) ((lib!betree.BufferOffsets_v.BufferOffsets./BufferOffsets (lib!betree.BufferOffsets_v.BufferOffsets./BufferOffsets/?offsets vstd!seq.Seq<nat.>.))) ((lib!betree.Buffer_v.SimpleBuffer./SimpleBuffer (lib!betree.Buffer_v.SimpleBuffer./SimpleBuffer/?map vstd!map.Map<lib!spec.KeyType_t.Key./lib!spec.Messages_t.Message.>.))) ((lib!betree.Domain_v.Domain./EmptyDomain) (lib!betree.Domain_v.Domain./Domain (lib!betree.Domain_v.Domain./Domain/?start lib!spec.KeyType_t.Element.) (lib!betree.Domain_v.Domain./Domain/?end lib!spec.KeyType_t.Element.))) ((lib!betree.LinkedBetree_v.BetreeNode./BetreeNode (lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/?buffers lib!betree.LinkedSeq_v.LinkedSeq.) (lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/?pivots lib!betree.PivotTable_v.PivotTable.) (lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/?children vstd!seq.Seq<core!option.Option<lib!spec.AsyncDisk_t.Address.>.>.) (lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/?flushed lib!betree.BufferOffsets_v.BufferOffsets.))) ((lib!betree.LinkedBetree_v.DiskView./DiskView (lib!betree.LinkedBetree_v.DiskView./DiskView/?entries vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>.))) ((lib!betree.LinkedBetree_v.TwoAddrs./TwoAddrs (lib!betree.LinkedBetree_v.TwoAddrs./TwoAddrs/?addr1 lib!spec.AsyncDisk_t.Address.) (lib!betree.LinkedBetree_v.TwoAddrs./TwoAddrs/?addr2 lib!spec.AsyncDisk_t.Address.))) ((lib!betree.LinkedBetree_v.SplitAddrs./SplitAddrs (lib!betree.LinkedBetree_v.SplitAddrs./SplitAddrs/?left lib!spec.AsyncDisk_t.Address.) (lib!betree.LinkedBetree_v.SplitAddrs./SplitAddrs/?right lib!spec.AsyncDisk_t.Address.) (lib!betree.LinkedBetree_v.SplitAddrs./SplitAddrs/?parent lib!spec.AsyncDisk_t.Address.))) ((lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/?root core!option.Option.) (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/?dv lib!betree.LinkedBetree_v.DiskView.) (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/?buffer_dv lib!betree.BufferDisk_v.BufferDisk.))) ((lib!betree.LinkedBetree_v.QueryReceiptLine./QueryReceiptLine (lib!betree.LinkedBetree_v.QueryReceiptLine./QueryReceiptLine/?linked lib!betree.LinkedBetree_v.LinkedBetree.) (lib!betree.LinkedBetree_v.QueryReceiptLine./QueryReceiptLine/?result lib!spec.Messages_t.Message.))) ((lib!betree.LinkedBetree_v.QueryReceipt./QueryReceipt (lib!betree.LinkedBetree_v.QueryReceipt./QueryReceipt/?key lib!spec.KeyType_t.Key.) (lib!betree.LinkedBetree_v.QueryReceipt./QueryReceipt/?linked lib!betree.LinkedBetree_v.LinkedBetree.) (lib!betree.LinkedBetree_v.QueryReceipt./QueryReceipt/?lines Poly))) ((lib!betree.LinkedBetree_v.Path./Path (lib!betree.LinkedBetree_v.Path./Path/?linked lib!betree.LinkedBetree_v.LinkedBetree.) (lib!betree.LinkedBetree_v.Path./Path/?key lib!spec.KeyType_t.Key.) (lib!betree.LinkedBetree_v.Path./Path/?depth Int))) ((lib!betree.LinkedSeq_v.LinkedSeq./LinkedSeq (lib!betree.LinkedSeq_v.LinkedSeq./LinkedSeq/?addrs vstd!seq.Seq<lib!spec.AsyncDisk_t.Address.>.))) ((lib!betree.Memtable_v.Memtable./Memtable (lib!betree.Memtable_v.Memtable./Memtable/?buffer Poly) (lib!betree.Memtable_v.Memtable./Memtable/?seq_end Int))) ((lib!betree.OffsetMap_v.OffsetMap./OffsetMap (lib!betree.OffsetMap_v.OffsetMap./OffsetMap/?offsets vstd!map.Map<lib!spec.KeyType_t.Key./nat.>.))) ((lib!betree.PivotTable_v.PivotTable./PivotTable (lib!betree.PivotTable_v.PivotTable./PivotTable/?pivots vstd!seq.Seq<lib!spec.KeyType_t.Element.>.))) ((lib!betree.SplitRequest_v.SplitRequest./SplitLeaf (lib!betree.SplitRequest_v.SplitRequest./SplitLeaf/?child_idx Int) (lib!betree.SplitRequest_v.SplitRequest./SplitLeaf/?split_key lib!spec.KeyType_t.Key.)) (lib!betree.SplitRequest_v.SplitRequest./SplitIndex (lib!betree.SplitRequest_v.SplitRequest./SplitIndex/?child_idx Int) (lib!betree.SplitRequest_v.SplitRequest./SplitIndex/?child_pivot_idx Int))) ((lib!spec.AsyncDisk_t.Address./Address (lib!spec.AsyncDisk_t.Address./Address/?au Int) (lib!spec.AsyncDisk_t.Address./Address/?page Int))) ((lib!spec.KeyType_t.Key./Key (lib!spec.KeyType_t.Key./Key/?0 Int))) ((lib!spec.KeyType_t.Element./Max) (lib!spec.KeyType_t.Element./Elem (lib!spec.KeyType_t.Element./Elem/?e Int))) ((lib!spec.Messages_t.Value./Value (lib!spec.Messages_t.Value./Value/?0 Int))) ((lib!spec.Messages_t.Delta./Delta (lib!spec.Messages_t.Delta./Delta/?0 Int))) ((lib!spec.Messages_t.Message./Define (lib!spec.Messages_t.Message./Define/?value lib!spec.Messages_t.Value.)) (lib!spec.Messages_t.Message./Update (lib!spec.Messages_t.Message./Update/?delta lib!spec.Messages_t.Delta.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly)))))
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/buffers (lib!betree.LinkedBetree_v.BetreeNode.) lib!betree.LinkedSeq_v.LinkedSeq.)
(declare-fun lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/pivots (lib!betree.LinkedBetree_v.BetreeNode.) lib!betree.PivotTable_v.PivotTable.)
(declare-fun lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/children (lib!betree.LinkedBetree_v.BetreeNode.) vstd!seq.Seq<core!option.Option<lib!spec.AsyncDisk_t.Address.>.>.)
(declare-fun flushed (lib!betree.LinkedBetree_v.BetreeNode.) lib!betree.BufferOffsets_v.BufferOffsets.)
(declare-fun lib!betree.LinkedBetree_v.DiskView./DiskView/entries (lib!betree.LinkedBetree_v.DiskView.) vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>.)
(declare-fun lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (lib!betree.LinkedBetree_v.LinkedBetree.) core!option.Option.)
(declare-fun lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/dv (lib!betree.LinkedBetree_v.LinkedBetree.) lib!betree.LinkedBetree_v.DiskView.)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-const TYPE%lib!betree.LinkedBetree_v.BetreeNode. Type)
(declare-fun TYPE%lib!betree.LinkedBetree_v.LinkedBetree. (Dcr Type) Type)
(declare-const TYPE%lib!spec.AsyncDisk_t.Address. Type)
(declare-fun Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>.) Poly)
(declare-fun Poly%vstd!seq.Seq<core!option.Option<lib!spec.AsyncDisk_t.Address.>.>. (vstd!seq.Seq<core!option.Option<lib!spec.AsyncDisk_t.Address.>.>.) Poly)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun buffoffset (lib!betree.BufferOffsets_v.BufferOffsets.) Poly)
(declare-fun node (lib!betree.LinkedBetree_v.BetreeNode.) Poly)
(declare-fun %node (Poly) lib!betree.LinkedBetree_v.BetreeNode.)
(declare-fun Poly%lib!betree.LinkedBetree_v.DiskView. (lib!betree.LinkedBetree_v.DiskView.) Poly)
(declare-fun %Poly%lib!betree.LinkedBetree_v.DiskView. (Poly) lib!betree.LinkedBetree_v.DiskView.)
(declare-fun %Poly%lib!betree.LinkedBetree_v.LinkedBetree. (Poly) lib!betree.LinkedBetree_v.LinkedBetree.)
(declare-fun Poly%lib!betree.LinkedSeq_v.LinkedSeq. (lib!betree.LinkedSeq_v.LinkedSeq.) Poly)
(declare-fun Poly%lib!betree.PivotTable_v.PivotTable. (lib!betree.PivotTable_v.PivotTable.) Poly)
(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))))))
(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))
(assert (forall ((x lib!betree.LinkedBetree_v.BetreeNode.)) (! (= x (%node (node x))) :pattern ((node x)))))
(assert (forall ((T&. Dcr) (T& Type) (x Poly)) (! (=> (has_type x (TYPE%lib!betree.LinkedBetree_v.LinkedBetree. T&. T&)) (has_type (Poly%core!option.Option. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. x))) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) :pattern ((lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. x)) (has_type x (TYPE%lib!betree.LinkedBetree_v.LinkedBetree. T&. T&))))))
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(declare-fun lib!betree.PivotTable_v.impl&%0.num_ranges.? (Poly) Int)
(declare-fun lib!betree.PivotTable_v.impl&%0.wf.? (Poly) Bool)
(declare-fun lib!betree.BufferOffsets_v.impl&%0.len.? (Poly) Int)
(declare-fun lib!betree.BufferOffsets_v.impl&%0.all_lte.? (Poly Poly) Bool)
(declare-fun lib!betree.LinkedSeq_v.impl&%0.len.? (Poly) Int)
(declare-fun lib!betree.LinkedBetree_v.impl&%0.wf.? (Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%1.entries_wf.? (Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%0.valid_child_index.? (Poly Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.? (Poly Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%1.healthy_child_ptrs.? (Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%1.wf.? (Poly) Bool)
(declare-fun impl5 (Dcr Type Poly) Bool)
(declare-fun hasroot (Dcr Type Poly) Bool)
(declare-fun lib!betree.LinkedBetree_v.impl&%1.get.? (Poly Poly) lib!betree.LinkedBetree_v.BetreeNode.)
(declare-fun impl5root (Dcr Type Poly) lib!betree.LinkedBetree_v.BetreeNode.)
(declare-fun lib!betree.LinkedBetree_v.impl&%0.occupied_child_index.? (Poly Poly) Bool)
(declare-fun lib!betree.BufferOffsets_v.impl&%0.all_gte.? (Poly Poly) Bool)
(declare-fun lib!betree.BufferOffsets_v.impl&%0.update.? (Poly Poly Poly) lib!betree.BufferOffsets_v.BufferOffsets.)
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%0.wf.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%0.wf.) (forall ((self! Poly)) (! (= (lib!betree.LinkedBetree_v.impl&%0.wf.? self!) (and true (lib!betree.BufferOffsets_v.impl&%0.all_lte.? (buffoffset (flushed (%node self!))) (I (lib!betree.LinkedSeq_v.impl&%0.len.? (Poly%lib!betree.LinkedSeq_v.LinkedSeq. (lib!betree.LinkedBetree_v.BetreeNode./BetreeNode/buffers (%node self!)))))))) :pattern ((lib!betree.LinkedBetree_v.impl&%0.wf.? self!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%1.entries_wf.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%1.entries_wf.) (forall ((self! Poly)) (! (= (lib!betree.LinkedBetree_v.impl&%1.entries_wf.? self!) (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!)))) addr$) (lib!betree.LinkedBetree_v.impl&%0.wf.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!))) addr$)))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!)))) addr$))))) :pattern ((lib!betree.LinkedBetree_v.impl&%1.entries_wf.? self!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%0.valid_child_index.))
(assert true)
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.? self! ptr!) (=> (is-core!option.Option./Some_ (%Poly%core!option.Option. ptr!)) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. ptr!))))) :pattern ((lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.? self! ptr!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%1.wf.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%1.wf.) (forall ((self! Poly)) (! (= (lib!betree.LinkedBetree_v.impl&%1.wf.? self!) (and (and (lib!betree.LinkedBetree_v.impl&%1.entries_wf.? self!) (lib!betree.LinkedBetree_v.impl&%1.healthy_child_ptrs.? self!)) (vstd!set.impl&%0.finite.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!))))))) :pattern ((lib!betree.LinkedBetree_v.impl&%1.wf.? self!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%5.wf.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%5.wf.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (impl5 T&. T& self!) (and (lib!betree.LinkedBetree_v.impl&%1.wf.? (Poly%lib!betree.LinkedBetree_v.DiskView. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/dv (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!)))) (lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.? (Poly%lib!betree.LinkedBetree_v.DiskView. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/dv (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!))) (Poly%core!option.Option. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!)))))) :pattern ((impl5 T&. T& self!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%5.has_root.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%5.has_root.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (hasroot T&. T& self!) (and (is-core!option.Option./Some_ (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!))) (lib!betree.LinkedBetree_v.impl&%1.is_nondangling_ptr.? (Poly%lib!betree.LinkedBetree_v.DiskView. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/dv (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!))) (Poly%core!option.Option. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!)))))) :pattern ((hasroot T&. T& self!))))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%1.get.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%1.get.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!betree.LinkedBetree_v.impl&%1.get.? self! ptr!) (%node (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!betree.LinkedBetree_v.BetreeNode. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!betree.LinkedBetree_v.BetreeNode.>. (lib!betree.LinkedBetree_v.DiskView./DiskView/entries (%Poly%lib!betree.LinkedBetree_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. ptr!))))) :pattern ((lib!betree.LinkedBetree_v.impl&%1.get.? self! ptr!))))))
(declare-fun req%lib!betree.LinkedBetree_v.impl&%5.root. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%40 Bool)
(assert (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (req%lib!betree.LinkedBetree_v.impl&%5.root. T&. T& self!) true) :pattern ((req%lib!betree.LinkedBetree_v.impl&%5.root. T&. T& self!)))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%5.root.))
(assert (=> (fuel_bool fuel%lib!betree.LinkedBetree_v.impl&%5.root.) (forall ((T&. Dcr) (T& Type) (self! Poly)) (! (= (impl5root T&. T& self!) (lib!betree.LinkedBetree_v.impl&%1.get.? (Poly%lib!betree.LinkedBetree_v.DiskView. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/dv (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!))) (Poly%core!option.Option. (lib!betree.LinkedBetree_v.LinkedBetree./LinkedBetree/root (%Poly%lib!betree.LinkedBetree_v.LinkedBetree. self!))))) :pattern ((impl5root T&. T& self!))))))
(declare-fun child_index (Poly Poly) Bool)
(declare-const %%global_location_label%%80 Bool)
(assert (forall ((self! Poly) (child_idx! Poly)) (! (= (child_index self! child_idx!) (=> true (lib!betree.LinkedBetree_v.impl&%0.wf.? self!))) :pattern ((child_index self! child_idx!)))))
(assert (fuel_bool_default fuel%lib!betree.LinkedBetree_v.impl&%0.occupied_child_index.))
;(assert true)
(declare-fun req%lib!betree.BufferOffsets_v.impl&%0.update. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%81 Bool)
;(assert (forall ((self! Poly) (idx! Poly) (value! Poly)) (! true :pattern ((req%lib!betree.BufferOffsets_v.impl&%0.update. self! idx! value!)))))
(declare-const T&. Dcr)
(declare-const T& Type)
(declare-const self! Poly)
(declare-const child_idx! Poly)
(declare-const buffer_gc! Poly)
(declare-const tmp%1 lib!betree.LinkedBetree_v.BetreeNode.)
(declare-const tmp%2 Bool)
(declare-const tmp%3 Bool)
(declare-const tmp%4 lib!betree.LinkedBetree_v.BetreeNode.)
(declare-const tmp%5 lib!betree.LinkedBetree_v.BetreeNode.)
(declare-const tmp%6 lib!betree.BufferOffsets_v.BufferOffsets.)
(declare-const tmp%7 Poly)
(declare-const tmp%8 Poly)
(declare-const tmp%9 Bool)
(assert true)
(assert (has_type self! (TYPE%lib!betree.LinkedBetree_v.LinkedBetree. T&. T&)))
(assert (has_type child_idx! NAT))
(declare-const %%switch_label%%0 Bool)
(declare-const %%switch_label%%1 Bool)
(declare-const %%location_label%%0 Bool)
(declare-const %%location_label%%1 Bool)
(declare-const %%location_label%%2 Bool)
(declare-const %%location_label%%3 Bool)
(declare-const %%location_label%%4 Bool)
(assert (not (or (and (=> (and (impl5 T&. T& self!) (hasroot T&. T& self!)) (and true (=> (= tmp%1 (impl5root T&. T& self!)) (and (child_index (node tmp%1) child_idx!) true)))) true) (and (not %%switch_label%%1) (or (and (=> tmp%3 (and (=> %%location_label%%2 (req%lib!betree.LinkedBetree_v.impl&%5.root. T&. T& self!)) (=> (= tmp%4 (impl5root T&. T& self!)) (and (=> %%location_label%%3 (req%lib!betree.LinkedBetree_v.impl&%5.root. T&. T& self!)) (=> (= tmp%5 (impl5root T&. T& self!)) (=> (= tmp%7 (buffoffset (flushed (%node (node tmp%4))))) false)))))) true) false)))))
(check-sat)
