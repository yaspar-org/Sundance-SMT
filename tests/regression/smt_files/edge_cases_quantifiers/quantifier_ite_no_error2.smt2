(declare-sort F 0)
(declare-fun s (F) F)
(declare-sort P 0)
(declare-sort T 0)
(declare-sort D 0)
(declare-const $ D)
(declare-sort t 0)
(declare-sort s 0)
(declare-sort v 0)
;(declare-datatypes ((li 0) (lib!betree.PivotBranch_v.Node. 0) (lib!betree.PivotBranch_v.Path. 0) (lib!spec.KeyType_t.Key. 0) (lib!spec.Messages_t.Value. 0) (lib!spec.Messages_t.Delta. 0) (lib!spec.Messages_t.Message. 0) (tuple%0. 0) (tuple%2. 0)) (((lib!betree.PivotBranch_v.SplitArg./SplitIndex (lib!betree.PivotBranch_v.SplitArg./SplitIndex/?pivot lib!spec.KeyType_t.Key.) (lib!betree.PivotBranch_v.SplitArg./SplitIndex/?pivot_index Int))) ((lib!betree.PivotBranch_v.Node./Leaf (lib!betree.PivotBranch_v.Node./Leaf/?keys t) (lib!betree.PivotBranch_v.Node./Leaf/?msgs s))) ((lib!betree.PivotBranch_v.Path./Path (lib!betree.PivotBranch_v.Path./Path/?node lib!betree.PivotBranch_v.Node.) (lib!betree.PivotBranch_v.Path./Path/?key lib!spec.KeyType_t.Key.) (lib!betree.PivotBranch_v.Path./Path/?depth Int))) ((lib!spec.KeyType_t.Key./Key (lib!spec.KeyType_t.Key./Key/?0 Int))) ((lib!spec.Messages_t.Value./Value (lib!spec.Messages_t.Value./Value/?0 Int))) ((lib!spec.Messages_t.Delta./Delta (lib!spec.Messages_t.Delta./Delta/?0 Int))) ((lib!spec.Messages_t.Message./Update (lib!spec.Messages_t.Message./Update/?delta lib!spec.Messages_t.Delta.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 P) (tuple%2./tuple%2/?1 P)))))
(declare-sort lib!betree.PivotBranch_v.Node. 0)
(declare-fun is-lib!betree.PivotBranch_v.Node./Leaf (lib!betree.PivotBranch_v.Node.) Bool)
(declare-fun l (lib!betree.PivotBranch_v.Node.) t)
(declare-const T T)
(declare-fun o (t) P)
(declare-fun Po (v) P)
(declare-fun P (lib!betree.PivotBranch_v.Node.) P)
(declare-fun % (P) lib!betree.PivotBranch_v.Node.)
(assert (forall ((x lib!betree.PivotBranch_v.Node.)) (! (= x (% (P x))) :pattern ((P x)))))
(declare-fun v (D T P P) Bool)
(declare-fun li (P) v)
(declare-fun i (P F) v)
(declare-const f F)
(assert (forall ((e P) (u F)) (! (= (i e (s u)) (li (ite (is-lib!betree.PivotBranch_v.Node./Leaf (% e)) (o (l (% e))) (o (l (% e)))))) :pattern ((i e (s u))))))
(assert (forall ((e P)) (! (= (li e) (i e (s f))) :pattern ((li e)))))
(declare-const n lib!betree.PivotBranch_v.Node.)
(declare-const p lib!betree.PivotBranch_v.Node.)
(assert (or (not (is-lib!betree.PivotBranch_v.Node./Leaf n)) (not (v $ T (Po (li (P n))) (o (l (% (P p))))))))
(check-sat)