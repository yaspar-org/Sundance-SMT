(declare-sort %% 0)
(declare-sort P 0)
(declare-fun % (%% P) Bool)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-const $ D)
(declare-fun a (P) Bool)
(declare-sort vs 0)
(declare-datatypes ((c 0) (l 0) (lib!delegation_map_v 0) (lib!delegation_map_v.DelegationMap. 0) (lib!delegation_map_t.AbstractDelegationMap. 0) (lib!io_t.EndPoint. 0) (lib!keys_t.KeyIterator. 0) (lib!keys_t.KeyRange. 0)) (((core!option.Option./Some (core!option.Option./Some/?0 vs))) ((lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec (lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec/?v vs))) ((lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?keys l) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?vals vs) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?m vs))) ((lib!delegation_map_v.DelegationMap./DelegationMap (lib!delegation_map_v.DelegationMap./DelegationMap/?lows lib!delegation_map_v) (lib!delegation_map_v.DelegationMap./DelegationMap/?m vs))) ((libd (libd/?0 vs))) ((lib!io_t.EndPoint./EndPoint (lib!io_t.EndPoint./EndPoint/?id vs))) ((lib!keys_t.KeyIterator./KeyIterator (lib!keys_t.KeyIterator./KeyIterator/?k c))) ((lib!keys_t.KeyRange./KeyRange (lib!keys_t.KeyRange./KeyRange/?lo lib!keys_t.KeyIterator.) (lib!keys_t.KeyRange./KeyRange/?hi lib!keys_t.KeyIterator.)))))
(declare-fun b (lib!delegation_map_t.AbstractDelegationMap.) vs)
(declare-fun T (T) T)
(declare-const TY T)
(declare-const Y T)
(declare-fun P () P)
(declare-fun %P (P) %%)
(declare-fun Pol () P)
(declare-fun %Po (P) vs)
(declare-fun y (lib!delegation_map_v.DelegationMap.) P)
(declare-fun o (lib!delegation_map_t.AbstractDelegationMap.) P)
(declare-fun Po (P) lib!delegation_map_t.AbstractDelegationMap.)
(declare-fun %% (%% P) P)
(declare-fun v (P) P)
(declare-fun s () Bool)
(declare-fun vs (P) P)
(declare-fun d (D P) P)
(declare-fun t () P)
(declare-fun st (P P) P)
(declare-fun vst () P)
(assert (forall ((s P)) (! (a (vs s)) :pattern ((vs s)))))
(assert (forall ((f P)) (! (= (% (%P f) f) s) :pattern ((%P f)))))
(declare-fun %%l (D T P) %%)
(assert (forall ((% D) (h T) (%%hole%%2 P) (k$ P)) (! (= (%% (%%l % h %%hole%%2) k$) (ite s vst (vs k$))) :pattern ((%% (%%l % h %%hole%%2) k$)))))
(declare-fun l () %%)
(declare-fun %l () %%)
(declare-const p lib!delegation_map_v.DelegationMap.)
(assert (= t (st P P)))
(assert (= (v t) (d $ P)))
(assert (= l (%P P)))
(assert (exists ((T P)) (! (not (a (%% (%%l $ Y (v (st P P))) T))) :pattern ((%% (%%l $ Y P) T)))))
(assert (not (% l P)))
(check-sat)
