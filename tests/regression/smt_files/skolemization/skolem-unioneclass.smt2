(declare-sort %% 0)
(declare-sort P 0)
(declare-fun % (%% P) Bool)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-const $ D)
(declare-fun a (P) Bool)
(declare-sort vs 0)
(declare-datatypes ((c 0) (l 0) (lib!delegation_map_v 0) (lib!delegation_map_v.DelegationMap. 0) (lib!delegation_map_t.AbstractDelegationMap. 0) (lib!io_t.EndPoint. 0) (lib!keys_t.KeyIterator. 0) (lib!keys_t.KeyRange. 0)) (((core!option.Option./Some (core!option.Option./Some/?0 vs))) ((lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec (lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec/?v vs))) ((lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?keys l) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?vals vs) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?m vs))) ((lib!delegation_map_v.DelegationMap./DelegationMap (lib!delegation_map_v.DelegationMap./DelegationMap/?lows lib!delegation_map_v) (lib!delegation_map_v.DelegationMap./DelegationMap/?m vs))) ((libd (libd/?0 vs))) ((lib!io_t.EndPoint./EndPoint (lib!io_t.EndPoint./EndPoint/?id vs))) ((lib!keys_t.KeyIterator./KeyIterator (lib!keys_t.KeyIterator./KeyIterator/?k c))) ((lib!keys_t.KeyRange./KeyRange (lib!keys_t.KeyRange./KeyRange/?lo lib!keys_t.KeyIterator.) (lib!keys_t.KeyRange./KeyRange/?hi lib!keys_t.KeyIterator.)))))
(declare-fun b (lib!delegation_map_t.AbstractDelegationMap.) vs)
(declare-fun T (T) T)
(declare-const TY T)
(declare-const Y T)
(declare-fun P () P)
(declare-fun %P (P) %%)
(declare-fun Pol () P)
(declare-fun %Po (P) vs)
(declare-fun y (lib!delegation_map_v.DelegationMap.) P)
(declare-fun o (lib!delegation_map_t.AbstractDelegationMap.) P)
(declare-fun Po (P) lib!delegation_map_t.AbstractDelegationMap.)
(declare-fun %% (%% P) P)
(declare-fun v (P) P)
(declare-fun s (P) Bool)
(declare-fun vs (P) P)
(declare-fun d () P)
(declare-fun t () P)
(declare-fun st (P P) P)
(declare-fun vst () P)
(assert (forall ((s P)) (! (a (vs s)) :pattern ((vs s)))))
;(assert (forall ((& D) (f P)) (! (not (s (d & f))) :pattern ((s (d & f))))))
(assert (not (s d)))
(declare-fun %%l (P) %%)
(assert (forall ((%%hole%%2 P) (k$ P)) (! (= (%% (%%l %%hole%%2) k$) (ite (s %%hole%%2) vst (vs k$))) :pattern ((%% (%%l %%hole%%2) k$)))))
(declare-fun l () %%)
(declare-fun %l () %%)
(declare-const p lib!delegation_map_v.DelegationMap.)
(assert (= t (st P P)))
(assert (= (v t) d))
(assert (exists ((T P)) (! (not (a (%% (%%l (v (st P P))) T))) :pattern ((%% (%%l P) T)))))
; note skolemizing here is enough to get sundance to return unsat
;(declare-const !!skolem_variable_0_ P)
;(assert (not (a (%% (%%l (v (st P P))) !!skolem_variable_0_))))
(check-sat)
