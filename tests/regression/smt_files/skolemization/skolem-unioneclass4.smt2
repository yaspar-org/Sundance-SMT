(declare-sort %% 0)
(declare-sort P 0)
(declare-fun B (Bool) P)
(declare-fun % (P) Bool)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-const $ D)
(declare-fun a (P T) Bool)
(declare-sort a 0)
(declare-sort al 0)
(declare-sort vs 0)
(declare-datatypes ((c 0) (lib!d 0) (lib!delegation_map_v.StrictlyOrderedMap. 0) (lib!delegation_map_v.DelegationMap. 0) (lib!abstract_end_point_t.AbstractEndPoint. 0) (lib!delegation_map_t.AbstractDelegationMap. 0) (lib!io_t.EndPoint. 0) (lib!keys_t.KeyIterator. 0) (lib!keys_t.KeyRange. 0) (tuple%0. 0) (tuple%2. 0)) (((core!option.Option./Some (core!option.Option./Some/?0 vs))) ((lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec (lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec/?v vs))) ((lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?keys lib!d) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?vals al) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?m vs))) ((lib!delegation_map_v.DelegationMap./DelegationMap (lib!delegation_map_v.DelegationMap./DelegationMap/?lows lib!delegation_map_v.StrictlyOrderedMap.) (lib!delegation_map_v.DelegationMap./DelegationMap/?m vs))) ((lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint (lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint/?id vs))) ((lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap/?0 vs))) ((lib!io_t.EndPoint./EndPoint (lib!io_t.EndPoint./EndPoint/?id vs))) ((lib!keys_t.KeyIterator./KeyIterator (lib!keys_t.KeyIterator./KeyIterator/?k c))) ((lib!keys_t.KeyRange./KeyRange (lib!keys_t.KeyRange./KeyRange/?lo lib!keys_t.KeyIterator.) (lib!keys_t.KeyRange./KeyRange/?hi lib!keys_t.KeyIterator.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 vs) (tuple%2./tuple%2/?1 vs)))))
(declare-fun b (lib!delegation_map_t.AbstractDelegationMap.) vs)
(declare-fun i (lib!keys_t.KeyRange.) lib!keys_t.KeyIterator.)
(declare-fun TY (T) T)
(declare-const TYP T)
(declare-const Y T)
(declare-fun P (%%) P)
(declare-fun %P (P) %%)
(declare-fun Poly%v (vs) P)
(declare-fun %Pol (P) vs)
(declare-fun y (lib!delegation_map_v.DelegationMap.) P)
(declare-fun ly (lib!abstract_end_point_t.AbstractEndPoint.) P)
(declare-fun oly (lib!delegation_map_t.AbstractDelegationMap.) P)
(declare-fun Poly (P) lib!delegation_map_t.AbstractDelegationMap.)
(declare-fun o (lib!io_t.EndPoint.) P)
(declare-fun ol (lib!keys_t.KeyIterator.) P)
(declare-fun Po (P) lib!keys_t.KeyIterator.)
(declare-fun Pol (lib!keys_t.KeyRange.) P)
(declare-fun %Po (P) lib!keys_t.KeyRange.)
(declare-fun %% (%% P) P)
(assert (forall ((x lib!keys_t.KeyRange.)) (! (= (i x) (lib!keys_t.KeyRange./KeyRange/?hi x)) :pattern ((i x)))))
(declare-fun v (D T D T P) P)
(declare-fun s (D T P P) Bool)
(declare-fun vs (D T D T P P) P)
(declare-fun td (D T D T P) P)
(declare-fun t (D T D T D T P P) P)
(declare-fun li (P) lib!abstract_end_point_t.AbstractEndPoint.)
(declare-fun vst (P P) P)
(declare-fun ib! (D T P P P) Bool)
(declare-fun ib (D T P) lib!keys_t.KeyIterator.)
(declare-fun lib (P P) Bool)
(declare-fun vstd (D T D T P P) P)
(assert (forall ((& D) (K T) (. D) (V& T) (self! P) (key! P)) (! (a (vs . Y . V& self! self!) V&) :pattern ((vs & K . V& self! key!)))))
(assert (forall ((& D) (f P) (a P)) (! (= (% (%% (%P f) f)) (s & Y (td & Y & (TY O) f) a)) :pattern ((s & Y (td & Y & (TY O) f) a)))))
(declare-fun %%l (D T P D T D T P D T D T P) %%)
(assert (forall ((% D) (%%ho T) (%%hole%%2 P) (%%hole%%3 D) (%%hole%%4 T) (%%hole%%5 D) (%%hole%%6 T) (%%hole%%7 P) (%%hole%%8 D) (%%hole%%9 T) (%%hole%%10 D) (%%hole%%11 T) (%%hole%%12 P) (k$ P)) (! (= (%% (%%l %%hole%%3 Y %%hole%%2 %%hole%%3 Y %%hole%%3 TYP %%hole%%7 %%hole%%3 Y %%hole%%3 TYP %%hole%%12) k$) (ite (s %%hole%%3 Y %%hole%%2 k$) (vstd %%hole%%3 Y %%hole%%3 Y k$ k$) (vs %%hole%%3 Y %%hole%%3 TYP k$ k$))) :pattern ((%% (%%l % %%ho %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k$)))))
(declare-fun la (D T P) %%)
(declare-fun %l (P) %%)
(declare-const p lib!delegation_map_v.DelegationMap.)
(declare-const l lib!keys_t.KeyIterator.)
(declare-const d lib!io_t.EndPoint.)
(declare-fun pool (lib!keys_t.KeyIterator.) lib!keys_t.KeyIterator.)
(assert (forall ((k P)) (! (not (ib! $ Y (ol l) k (ol (pool l)))) :pattern ((ib! $ Y (ol l) k (ol l))))))
(assert (= (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l))) (%Po (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l)))))))
(assert (= (vst (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l)))))) (P (%l (ly (li (o d)))))) (t $ Y $ TYP $ (TY TYP) (P (%l (ly (li (o d))))) (td $ Y $ (TY O) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l))))))))))
(assert (= (td $ Y $ (TY O) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l))))))) (v $ Y $ TYP (t $ Y $ TYP $ (TY TYP) (P (%l (ly (li (o d))))) (td $ Y $ (TY O) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l)))))))))))
(assert (= (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l))))) (%P (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool (pool l)))))))))
(assert (= l (pool l)))
(assert (not (forall ((T P)) (! (or false (a (%% (%%l $ Y (v $ Y $ TYP (vst (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))))) (P (%l (ly (li (o d))))))) $ Y $ TYP (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))))) $ Y $ TYP (Poly%v (b (Poly (oly (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (%Pol (y p)))))))) T) TYP)) :pattern ((%% (%%l $ Y (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))))) $ Y $ Y (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))))) $ Y $ Y (Poly%v (b (Poly (oly (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (%Pol (y p)))))))) T))))))
(assert (= (%% (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))))) (B (lib (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))))))))
(assert (= (% (B (lib (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))) (P (la $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))))))) (ib! $ Y (ol (i (%Po (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))))) (ol (ib $ Y (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l))))) (ol (i (%Po (Pol (lib!keys_t.KeyRange./KeyRange (pool l) (pool l)))))))))
(check-sat)
