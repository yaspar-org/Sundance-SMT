(set-option :auto_config false)
(set-option :smt.mbqi false)

(declare-sort % 0)
(declare-sort F 0)
(declare-fun fuel_bool (F) Bool)
(declare-fun fuel_bool_default (F) Bool)
(assert (or (forall ((i F)) (! (= (fuel_bool i) (fuel_bool_default i)) :pattern ((fuel_bool i))))))
(declare-sort Poly 0)
(declare-fun B (Bool) Poly)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-fun has_type (Poly T) Bool)
(declare-fun sized (D) Bool)
(declare-fun mk_fun (%) %)
(assert (forall ((b Bool)) (! (has_type (B b) O) :pattern ((B b)))))
(assert (forall ((x Poly)) (! (not (has_type x O)) :pattern ((has_type x O)))))
(declare-fun ext_eq (Bool T Poly Poly) Bool)
(declare-const fuel%vstd!set.axiom_set_new. F)
(declare-const fuel%vstd!set.axiom_set_ext_equal. F)
(declare-const fuel%set_membership!set_union. F)
(declare-const fuel%set_membership!set_intersection. F)
(declare-const fuel%set_membership!set_difference. F)
(assert (and (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_new.)))
(declare-fun TYPE%vstd!set.Set. (D T) T)
(declare-fun Poly%fun%1. (%) Poly)
(declare-fun % (% Poly) Poly)
(declare-fun vstd!set.Set.contains.? (D T Poly Poly) Bool)
(declare-fun vstd!set.impl&%0.new.? (D T Poly) Poly)
(declare-fun set_membership!set_union.? (D T Poly Poly) Poly)
(declare-fun set_membership!set_intersection.? (D T Poly Poly) Poly)
(declare-fun s (D T Poly Poly) Poly)
(assert (or (not (fuel_bool fuel%vstd!set.axiom_set_new.)) (forall ((& D) (A T) (f Poly) (a Poly)) (! (and (has_type f O)) :pattern ((vstd!set.Set.contains.? & A (vstd!set.impl&%0.new.? & A f) a))))))
(assert (or (not (fuel_bool fuel%vstd!set.axiom_set_ext_equal.)) (forall ((& D) (A T) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. & A)) (has_type s2! (TYPE%vstd!set.Set. & A))) (=> (sized &) (= (ext_eq false (TYPE%vstd!set.Set. & A) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A) (= (vstd!set.Set.contains.? & A s1! a$) (vstd!set.Set.contains.? & A s2! a$))) :pattern ((vstd!set.Set.contains.? & A s1! a$)) :pattern ((vstd!set.Set.contains.? & A s2! a$)) ))))) :pattern ((ext_eq false (TYPE%vstd!set.Set. & A) s1! s2!))))))
(assert (fuel_bool_default fuel%set_membership!set_union.))
(declare-fun %%lambda%%0 (D T Poly D T Poly) %)
(assert (or (not (fuel_bool fuel%set_membership!set_union.)) (forall ((T&. D) (T& T) (s1! Poly) (s2! Poly)) (! (= (set_membership!set_union.? T&. T& s1! s2!) (vstd!set.impl&%0.new.? T&. T& (Poly%fun%1. (mk_fun (%%lambda%%0 T&. T& s1! T&. T& s2!))))) :pattern ((set_membership!set_union.? T&. T& s1! s2!))))))
(assert (fuel_bool_default fuel%set_membership!set_intersection.))
(declare-fun %%lambda%%1 (D T Poly D T Poly) %)
(assert (forall ((%% D) (h T) (%h Poly) (%%h D) (o T) (ho Poly) (x Poly)) (! (= (B false) (% (%%lambda%%1 %%h o x %%h o x) x)) :pattern ((% (%%lambda%%1 %% h %h %%h o ho) x)))))
(assert (or (not (fuel_bool fuel%set_membership!set_intersection.)) (forall ((T&. D) (T& T) (s1! Poly) (s2! Poly)) (! (= (set_membership!set_intersection.? T&. T& s1! s2!) (vstd!set.impl&%0.new.? T&. T& (Poly%fun%1. (mk_fun (%%lambda%%1 T&. T& s1! T&. T& s2!))))) :pattern ((set_membership!set_intersection.? T&. T& s1! s2!))))))
;(assert (or (not (fuel_bool fuel%set_membership!set_difference.)) (forall ((T&. D) (T& T) (s1! Poly) (s2! Poly)) (! true :pattern ((s T&. T& s1! s2!))))))
(declare-const T&. D)
(declare-const T& T)
(declare-const s1! Poly)
(declare-const s2! Poly)
(declare-const s3! Poly)
(assert (sized T&.))
(assert (not (ext_eq false (TYPE%vstd!set.Set. T&. T&) (set_membership!set_intersection.? T&. T& s1! (set_membership!set_union.? T&. T& s2! s3!)) (set_membership!set_union.? T&. T& (set_membership!set_intersection.? T&. T& s1! s2!) (set_membership!set_intersection.? T&. T& s1! s3!)))))

(check-sat)
