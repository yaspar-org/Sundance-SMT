(set-option :smt.arith.solver 2)
(declare-sort P 0)
(declare-fun I (Int) P)
(declare-sort T 0)
(declare-sort D 0)
(declare-const $ D)
(declare-fun h (P T) Bool)
(declare-sort v 0)
(declare-datatypes ((lib 0) (li 0)) (((u)) ((s (b Int)))))
(declare-fun l (li) Int)
(declare-const T T)
(declare-fun P (v) P)
(declare-fun ol (lib) P)
(declare-fun o (li) P)
(declare-fun % (P) li)
;(assert (forall ((x P)) (! (= x (o (% x))) :pattern ((h x T)))))
;(assert (forall ((x li)) (! (= (l x) (b x)) :pattern ((l x)))))
(declare-fun v (D T P) Int)
(declare-fun t (D T P P) P)
(declare-fun vs (D T P) P)
(declare-fun lib (P P) Bool)
(declare-fun ib (P P) Bool)
(declare-fun li (P) v)
(declare-fun i (P P) Int)
;(assert (forall ((& D) (A T) (s P) (i P)) (! (or (h (t & T s i) T)) :pattern ((t & A s i)))))
;(assert (or (forall ((& D) (A T) (s P)) (! (= (vs & T s) (t & T s (I (v & T s)))) :pattern ((vs & A s))))))
;(assert (or (forall ((a P) (b P)) (! (<= (l (% a)) (l (% b))) :pattern ((lib a b))))))
;(assert (or (forall ((a P) (b P)) (! (and (lib a b) (distinct a b)) :pattern ((ib a b))))))
;(assert (or (forall ((s P) (k P)) (! (and (forall ((i P)) (! (or (ib k (t $ T (P (li s)) i))) :pattern ((t $ T (P (li s)) i))))) :pattern ((i s k))))))
(declare-const k li)
(assert (h (o k) T))
(assert (lib (vs $ T (P (li (ol u)))) (o k)))
(assert (= (i (ol u) (o k)) (v $ T (P (li (ol u))))))


(assert (= (o k) (o (% (o k)))))
(assert (= (vs $ T (P (li (ol u)))) (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))))
(assert (<= (l (% (vs $ T (P (li (ol u)))))) (l (% (o k)))))
;(assert (forall ((i P)) (! (or (ib (o k) (t $ T (P (li (ol u))) i))) :pattern ((t $ T (P (li (ol u))) i)))))
(assert (= (l (% (vs $ T (P (li (ol u)))))) (b (% (vs $ T (P (li (ol u))))))))
(assert (= (l (% (o k))) (b (% (o k)))))
(assert (h (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u)))))) T))
(assert (ib (o k) (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))))
(assert (= (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u)))))) (o (% (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))))))
(assert (and (lib (o k) (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))) (not (= (o k) (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))))))
(assert (<= (l (% (o k))) (l (% (t $ T (P (li (ol u))) (I (v $ T (P (li (ol u))))))))))
(check-sat)
