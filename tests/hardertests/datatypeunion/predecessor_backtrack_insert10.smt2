(declare-sort %% 0)
(declare-sort P 0)
(declare-fun B (Bool) P)
(declare-fun % (P) Bool)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-const $ D)
(declare-fun h (P T) Bool)
(declare-fun m (%%) %%)
(assert (forall ((x %%)) (! (= x (m x)) :pattern ((m x)))))
(assert (forall ((x Bool)) (! (= x (% (B x))) :pattern ((B x)))))
(declare-sort a 0)
(declare-sort al 0)
(declare-sort vstd 0)
(declare-sort st 0)
(declare-sort vs 0)
(declare-sort s 0)
(declare-datatypes ((c 0) (vstd!raw_ptr.Metadata. 0) (vstd!raw_ptr.PtrData. 0) (lib!delegation_map_v.StrictlyOrderedVec. 0) (lib!delegation_map_v.StrictlyOrderedMap. 0) (lib!delegation_map_v.DelegationMap. 0) (lib!abstract_end_point_t.AbstractEndPoint. 0) (lib!delegation_map_t.AbstractDelegationMap. 0) (lib!io_t.EndPoint. 0) (lib!keys_t.KeyIterator. 0) (lib!keys_t.KeyRange. 0) (tuple%0. 0) (tuple%2. 0)) (((core!option.Option./None) (core!option.Option./Some (core!option.Option./Some/?0 vs))) ((vstd!raw_ptr.Metadata./Dyn (vstd!raw_ptr.Metadata./Dyn/?0 st))) ((vstd!raw_ptr.PtrData./PtrData (vstd!raw_ptr.PtrData./PtrData/?addr Int) (vstd!raw_ptr.PtrData./PtrData/?provenance vs) (vstd!raw_ptr.PtrData./PtrData/?metadata vstd!raw_ptr.Metadata.))) ((lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec (lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec/?v vs))) ((lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?keys lib!delegation_map_v.StrictlyOrderedVec.) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?vals al) (lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap/?m vs))) ((lib!delegation_map_v.DelegationMap./DelegationMap (lib!delegation_map_v.DelegationMap./DelegationMap/?lows lib!delegation_map_v.StrictlyOrderedMap.) (lib!delegation_map_v.DelegationMap./DelegationMap/?m vs))) ((lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint (lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint/?id vs))) ((lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap/?0 vstd))) ((lib!io_t.EndPoint./EndPoint (lib!io_t.EndPoint./EndPoint/?id a))) ((lib!keys_t.KeyIterator./KeyIterator (lib!keys_t.KeyIterator./KeyIterator/?k c))) ((lib!keys_t.KeyRange./KeyRange (lib!keys_t.KeyRange./KeyRange/?lo lib!keys_t.KeyIterator.) (lib!keys_t.KeyRange./KeyRange/?hi lib!keys_t.KeyIterator.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 vs) (tuple%2./tuple%2/?1 vs)))))
(declare-fun lib!del (lib!delegation_map_t.AbstractDelegationMap.) vstd)
(declare-fun ib!keys (lib!keys_t.KeyRange.) lib!keys_t.KeyIterator.)
(declare-fun lib!keys_t.Key (lib!keys_t.KeyRange.) lib!keys_t.KeyIterator.)
(declare-fun Y (D T D T) T)
(declare-const TYPE%lib!a T)
(declare-const TY T)
(declare-fun P (%%) P)
(declare-fun %P (P) %%)
(declare-fun Poly (vstd) P)
(declare-fun %Pol (P) vstd)
(declare-fun Poly%lib (lib!delegation_map_v.DelegationMap.) P)
(declare-fun Poly%lib! (lib!abstract_end_point_t.AbstractEndPoint.) P)
(declare-fun Pol (lib!delegation_map_t.AbstractDelegationMap.) P)
(declare-fun %Poly (P) lib!delegation_map_t.AbstractDelegationMap.)
(declare-fun o (lib!io_t.EndPoint.) P)
(declare-fun oly (lib!keys_t.KeyIterator.) P)
(declare-fun Po (P) lib!keys_t.KeyIterator.)
(declare-fun ol (lib!keys_t.KeyRange.) P)
(declare-fun oly% (P) lib!keys_t.KeyRange.)
(assert (forall ((x %%)) (! (= x (%P (P x))) :pattern ((P x)))))
(declare-fun %% (%% P) P)
(assert (forall ((T D) (% T) (T%1&. D) (T%1& T) (x %%)) (! (exists ((T P)) (! (not (h (%% x T) TYPE%lib!a)) :pattern ((%% x T)))) :pattern ((h (P (m x)) (Y T % T%1&. T%1&))))))
(assert (forall ((x lib!keys_t.KeyIterator.)) (! (= x (Po (oly x))) :pattern ((oly x)))))
(assert (forall ((x lib!keys_t.KeyRange.)) (! (= (ib!keys x) (lib!keys_t.KeyRange./KeyRange/?lo x)) :pattern ((lib!keys_t.Key x)))))
(assert (forall ((x lib!keys_t.KeyRange.)) (! (= (lib!keys_t.Key x) (lib!keys_t.KeyRange./KeyRange/?hi x)) :pattern ((lib!keys_t.Key x)))))
(declare-fun v (D T D T P) P)
(declare-fun st (D T P P) Bool)
(declare-fun vs (D T D T P P) P)
(declare-fun vstd! (D T D T P) P)
(declare-fun vst (D T D T D T P P) P)
(declare-fun ib!i (P) lib!abstract_end_point_t.AbstractEndPoint.)
(declare-fun vstd!map. (D T D T D T D T P P) P)
(declare-fun lib!dele (D T P P P) Bool)
(declare-fun lib (D T P) lib!keys_t.KeyIterator.)
(declare-fun li (D T P P) Bool)
(declare-fun s (D T D T P P) P)
(declare-fun ib! (D T P) P)
(assert (forall ((& D) (K T) (V&. D) (V& T) (self! P) (key! P)) (! (or false (h (vs V&. TY V&. V& self! self!) V&)) :pattern ((vs & K V&. V& self! key!)))))
(assert (forall ((& D) (A T) (f! P) (a! P)) (! (= (% (%% (%P f!) f!)) (st & TY (vstd! & TY & (Y & TY & O) f!) a!)) :pattern ((st & TY (vstd! & TY & (Y & A & O) f!) a!)))))
(assert (forall ((& D) (K T) (self! P) (k! P)) (! (= (li & TY self! k!) (lib!dele & TY (oly (ib!keys (oly% self!))) (oly (lib & TYPE%lib!a self!)) (oly (lib!keys_t.Key (oly% self!))))) :pattern ((li & K self! k!)))))
(declare-fun %lamb (D T P D T D T P D T D T P) %%)
(assert (forall ((%%h D) (%%hole%%1 T) (%%hole%%2 P) (%%hole%%3 D) (%%hole%%4 T) (%%hole%%5 D) (%%hole%%6 T) (%%hole%%7 P) (%%hole%%8 D) (%%hole%%9 T) (%%hole%%10 D) (%%hole%%11 T) (%%hole%%12 P) (k$ P)) (! (= (%% (%lamb %%hole%%8 TY %%hole%%2 %%hole%%8 TY %%hole%%8 TYPE%lib!a %%hole%%7 %%hole%%8 TY %%hole%%8 TYPE%lib!a %%hole%%12) k$) (ite (st %%hole%%8 TY %%hole%%2 k$) (vs %%hole%%8 TYPE%lib!a %%hole%%8 TYPE%lib!a k$ k$) (vs %%hole%%8 TY %%hole%%8 TYPE%lib!a k$ k$))) :pattern ((%% (%lamb %%h %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k$)))))
(declare-fun %lambda%% (D T P) %%)
(assert (forall ((%%h D) (%%hole%%1 T) (%%hole%%2 P) (k$ P)) (! (= (%% (%lambda%% %%h TY %%hole%%2) k$) (B (li %%h TY %%hole%%2 k$))) :pattern ((%% (%lambda%% %%h %%hole%%1 %%hole%%2) k$)))))
(declare-fun %%l (P) %%)
(declare-const p lib!delegation_map_v.DelegationMap.)
(declare-const l lib!keys_t.KeyIterator.)
(declare-const i lib!keys_t.KeyIterator.)
(declare-const d lib!io_t.EndPoint.)
(assert (forall ((k P)) (! (not (lib!dele $ TY (oly l) k (oly i))) :pattern ((lib!dele $ TY (oly l) k (oly l))))))
(assert (= (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i))) (oly% (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))))
(assert (= (vstd!map. $ TY $ TYPE%lib!a $ (Y $ TY $ O) $ (Y $ TY $ TYPE%lib!a) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))) (P (%%l (Poly%lib! (ib!i (o d)))))) (vst $ TY $ TYPE%lib!a $ (Y $ TY $ TYPE%lib!a) (vstd! $ TY $ (Y $ TY $ O) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i))))))) (P (%%l (Poly%lib! (ib!i (o d))))))))
(assert (= (Poly (lib!del (%Poly (Pol (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (%Pol (Poly%lib p))))))) (P (m (%lamb $ TY (v $ TY $ TYPE%lib!a (vstd!map. $ TY $ TYPE%lib!a $ (Y $ TY $ O) $ (Y $ TY $ TYPE%lib!a) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))) (P (%%l (Poly%lib! (ib!i (o d))))))) $ TY $ TYPE%lib!a (vstd!map. $ TY $ TYPE%lib!a $ (Y $ TY $ O) $ (Y $ TY $ TYPE%lib!a) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))) (P (%%l (Poly%lib! (ib!i (o d)))))) $ TY $ TYPE%lib!a (Poly (lib!del (%Poly (Pol (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (%Pol (ib! $ TY (Poly%lib p)))))))))))))
(assert (= (v $ TY $ TYPE%lib!a (vst $ TY $ TYPE%lib!a $ (Y $ TY $ TYPE%lib!a) (vstd! $ TY $ (Y $ TY $ O) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i))))))) (P (%%l (Poly%lib! (ib!i (o d))))))) (vstd! $ TY $ (Y $ TY $ O) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))))))
(assert (and (h (P (%lamb $ TY (v $ TY $ TYPE%lib!a (vstd!map. $ TY $ TYPE%lib!a $ (Y $ TY $ O) $ (Y $ TY $ TYPE%lib!a) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))) (P (%%l (Poly%lib! (ib!i (o d))))))) $ TY $ TYPE%lib!a (vstd!map. $ TY $ TYPE%lib!a $ (Y $ TY $ O) $ (Y $ TY $ TYPE%lib!a) (P (%lambda%% $ TY (ol (lib!keys_t.KeyRange./KeyRange (Po (oly l)) (Po (oly i)))))) (P (%%l (Poly%lib! (ib!i (o d)))))) $ TY $ TYPE%lib!a (Poly (lib!del (%Poly (Pol (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (%Pol (ib! $ TY (Poly%lib p)))))))))) (Y $ TYPE%lib!a $ TYPE%lib!a))))

(check-sat)
