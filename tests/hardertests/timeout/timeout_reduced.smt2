(set-info :smt-lib-version 2.6)
(set-info :source |
Generated by: Amar Shah
Generated on: 2024-12-11
Generator: Verus
Application: Verification of Rust Program
Target solver: z3
Time limit: 60
Benchmarks generated by the Rust verifier Verus (https://verus-lang.github.io/verus/guide/) on the project Anvil (https://www.usenix.org/conference/osdi24/presentation/sun-xudong) 
and processed using Mariposa (https://github.com/secure-foundations/mariposa).
This benchmarks was originally run with z3 with the following options:
    (set-option :auto_config false)
    (set-option :smt.mbqi false)
    (set-option :smt.case_split 3)
    (set-option :smt.qi.eager_threshold 100.0)
    (set-option :smt.delay_units true)
    (set-option :smt.arith.solver 2)
    (set-option :smt.arith.nl false)
    (set-option :pi.enabled false)
    (set-option :rewriter.sort_disjunctions false)
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-datatypes ((fndef 0)) (((fndef_singleton))))
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun F (fndef) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun %F (Poly) fndef)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr Type Dcr) Dcr)
(declare-fun RC (Dcr Type Dcr) Dcr)
(declare-fun ARC (Dcr Type Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun CONST_PTR (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-const STRSLICE Type)
(declare-const ALLOCATOR_GLOBAL Type)
(declare-fun PTR (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)

;(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)) )))


(assert (forall ((x Poly) (t Type)) (! (and (has_type (as_type x t) t) (=> (has_type x t) (= x (as_type x t)))) :pattern ((as_type x t)))))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(declare-const SZ Int)
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)

;(assert (= (uHi 8) 256))



;(assert (= (uHi 16) 65536))



;(assert (= (uHi 32) 4294967296))



;(assert (= (uHi 64) 18446744073709551616))



;(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))



;(assert (= (iLo 8) (- 128)))



;(assert (= (iLo 16) (- 32768)))



;(assert (= (iLo 32) (- 2147483648)))



;(assert (= (iLo 64) (- 9223372036854775808)))



;(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))



;(assert (= (iHi 8) 128))



;(assert (= (iHi 16) 32768))



;(assert (= (iHi 32) 2147483648))



;(assert (= (iHi 64) 9223372036854775808))



;(assert (= (iHi 128) 170141183460469231731687303715884105728))


(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(declare-fun charClip (Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)))))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(declare-fun charInv (Int) Bool)
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)))))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)))))

;(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)))))


(declare-fun bitxor (Poly Poly) Int)
(declare-fun bitand (Poly Poly) Int)
(declare-fun bitor (Poly Poly) Int)
(declare-fun bitshr (Poly Poly) Int)
(declare-fun bitshl (Poly Poly) Int)
(declare-fun bitnot (Poly) Int)
(declare-fun singular_mod (Int Int) Int)
(declare-fun closure_req (Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Type Dcr Type Poly Poly Poly) Bool)
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)))))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(declare-const fuel%vstd!std_specs.option.impl&%0.is_Some. FuelId)
(declare-const fuel%vstd!std_specs.option.impl&%0.get_Some_0. FuelId)
(declare-const fuel%vstd!std_specs.option.spec_unwrap. FuelId)
(declare-const fuel%vstd!map.impl&%0.new. FuelId)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_finite. FuelId)
(declare-const fuel%vstd!map.axiom_map_index_decreases_infinite. FuelId)
(declare-const fuel%vstd!map.axiom_map_empty. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_domain. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_same. FuelId)
(declare-const fuel%vstd!map.axiom_map_insert_different. FuelId)
(declare-const fuel%vstd!map.axiom_map_remove_domain. FuelId)
(declare-const fuel%vstd!map.axiom_map_remove_different. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal. FuelId)
(declare-const fuel%vstd!map.axiom_map_ext_equal_deep. FuelId)
(declare-const fuel%vstd!map.check_argument_is_map. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.contains_key. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.submap_of. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.spec_le. FuelId)
(declare-const fuel%vstd!math.max. FuelId)
(declare-const fuel%vstd!set.impl&%0.subset_of. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty. FuelId)
(declare-const fuel%vstd!set.axiom_set_new. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_same. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_insert. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_different. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_domain. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_index. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_insert_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_remove_finite. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.wf. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.contains. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.contains_exactly. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.is_empty. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.can_follow. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.can_concat. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.can_discard_to. FuelId)
(declare-const fuel%lib!abstract_system.MsgHistory_v.impl&%0.discard_old. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%0.wf. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%0.has_link. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%0.contains_lsn. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.entries_wf. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.this_block_can_concat. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.blocks_each_have_link. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.block_in_bounds. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.wf. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.decodable. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.seq_start. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.seq_end. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.discard_old. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk_with_newer_lsn. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.can_crop. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.iptr. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.next. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.is_tight. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.lsn_has_entry_at. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.lsn_has_entry. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%1.lsns_have_entries. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.wf. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.seq_start. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.seq_end. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.can_discard_to. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.discard_old. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.valid_discard_old. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.decodable. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.can_crop. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.crop. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.append_record. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.build_tight. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.mkfs. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.lsns_have_entries. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%2.marshal_ranking. FuelId)
(declare-const fuel%lib!journal.LinkedJournal_v.impl&%3.bounded_discard. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (=> (fuel_bool_default fuel%vstd!map.group_map_axioms.) (and (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_finite.) (fuel_bool_default fuel%vstd!map.axiom_map_index_decreases_infinite.) (fuel_bool_default fuel%vstd!map.axiom_map_empty.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.) (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.) (fuel_bool_default fuel%vstd!map.axiom_map_remove_domain.) (fuel_bool_default fuel%vstd!map.axiom_map_remove_different.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal.) (fuel_bool_default fuel%vstd!map.axiom_map_ext_equal_deep.))))
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_empty.) (fuel_bool_default fuel%vstd!set.axiom_set_new.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_same.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_same.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_insert.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_different.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_domain.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_index.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_insert_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_remove_finite.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(declare-sort vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>. 0)
(declare-sort vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. 0)
(declare-sort vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. 0)
(declare-sort vstd!set.Set<nat.>. 0)
(declare-sort vstd!set.Set<lib!spec.AsyncDisk_t.Address.>. 0)
(declare-sort allocator_global%. 0)
(declare-datatypes ((core!option.Option. 0) (lib!abstract_system.MsgHistory_v.KeyedMessage. 0) (lib!abstract_system.MsgHistory_v.MsgHistory. 0) (lib!journal.LinkedJournal_v.JournalRecord. 0) (lib!journal.LinkedJournal_v.DiskView. 0) (lib!journal.LinkedJournal_v.TruncatedJournal. 0) (lib!journal.PagedJournal_v.JournalRecord. 0) (lib!spec.AsyncDisk_t.Address. 0) (lib!spec.KeyType_t.Key. 0) (lib!spec.Messages_t.Value. 0) (lib!spec.Messages_t.Delta. 0) (lib!spec.Messages_t.Message. 0) (tuple%0. 0)) (((core!option.Option./None) (core!option.Option./Some (core!option.Option./Some/?0 Poly))) ((lib!abstract_system.MsgHistory_v.KeyedMessage./KeyedMessage (lib!abstract_system.MsgHistory_v.KeyedMessage./KeyedMessage/?key lib!spec.KeyType_t.Key.) (lib!abstract_system.MsgHistory_v.KeyedMessage./KeyedMessage/?message lib!spec.Messages_t.Message.))) ((lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory (lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/?msgs vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>.) (lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/?seq_start Int) (lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/?seq_end Int))) ((lib!journal.LinkedJournal_v.JournalRecord./JournalRecord (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/?message_seq lib!abstract_system.MsgHistory_v.MsgHistory.) (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/?prior_rec core!option.Option.))) ((lib!journal.LinkedJournal_v.DiskView./DiskView (lib!journal.LinkedJournal_v.DiskView./DiskView/?boundary_lsn Int) (lib!journal.LinkedJournal_v.DiskView./DiskView/?entries vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>.))) ((lib!journal.LinkedJournal_v.TruncatedJournal./TruncatedJournal (lib!journal.LinkedJournal_v.TruncatedJournal./TruncatedJournal/?freshest_rec core!option.Option.) (lib!journal.LinkedJournal_v.TruncatedJournal./TruncatedJournal/?disk_view lib!journal.LinkedJournal_v.DiskView.))) ((lib!journal.PagedJournal_v.JournalRecord./JournalRecord (lib!journal.PagedJournal_v.JournalRecord./JournalRecord/?message_seq lib!abstract_system.MsgHistory_v.MsgHistory.) (lib!journal.PagedJournal_v.JournalRecord./JournalRecord/?prior_rec core!option.Option.))) ((lib!spec.AsyncDisk_t.Address./Address (lib!spec.AsyncDisk_t.Address./Address/?au Int) (lib!spec.AsyncDisk_t.Address./Address/?page Int))) ((lib!spec.KeyType_t.Key./Key (lib!spec.KeyType_t.Key./Key/?0 Int))) ((lib!spec.Messages_t.Value./Value (lib!spec.Messages_t.Value./Value/?0 Int))) ((lib!spec.Messages_t.Delta./Delta (lib!spec.Messages_t.Delta./Delta/?0 Int))) ((lib!spec.Messages_t.Message./Define (lib!spec.Messages_t.Message./Define/?value lib!spec.Messages_t.Value.)) (lib!spec.Messages_t.Message./Update (lib!spec.Messages_t.Message./Update/?delta lib!spec.Messages_t.Delta.))) ((tuple%0./tuple%0))))
(declare-fun core!option.Option./Some/0 (core!option.Option.) Poly)
(declare-fun lib!abstract_system.MsgHistory_v.KeyedMessage./KeyedMessage/key (lib!abstract_system.MsgHistory_v.KeyedMessage.) lib!spec.KeyType_t.Key.)
(declare-fun lib!abstract_system.MsgHistory_v.KeyedMessage./KeyedMessage/message (lib!abstract_system.MsgHistory_v.KeyedMessage.) lib!spec.Messages_t.Message.)
(declare-fun lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/msgs (lib!abstract_system.MsgHistory_v.MsgHistory.) vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>.)
(declare-fun lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/seq_start (lib!abstract_system.MsgHistory_v.MsgHistory.) Int)
(declare-fun lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/seq_end (lib!abstract_system.MsgHistory_v.MsgHistory.) Int)
(declare-fun lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/message_seq (lib!journal.LinkedJournal_v.JournalRecord.) lib!abstract_system.MsgHistory_v.MsgHistory.)
(declare-fun lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/prior_rec (lib!journal.LinkedJournal_v.JournalRecord.) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (lib!journal.LinkedJournal_v.DiskView.) Int)
(declare-fun lib!journal.LinkedJournal_v.DiskView./DiskView/entries (lib!journal.LinkedJournal_v.DiskView.) vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>.)
(declare-fun lib!journal.LinkedJournal_v.TruncatedJournal./TruncatedJournal/freshest_rec (lib!journal.LinkedJournal_v.TruncatedJournal.) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.TruncatedJournal./TruncatedJournal/disk_view (lib!journal.LinkedJournal_v.TruncatedJournal.) lib!journal.LinkedJournal_v.DiskView.)
(declare-fun lib!journal.PagedJournal_v.JournalRecord./JournalRecord/message_seq (lib!journal.PagedJournal_v.JournalRecord.) lib!abstract_system.MsgHistory_v.MsgHistory.)
(declare-fun lib!journal.PagedJournal_v.JournalRecord./JournalRecord/prior_rec (lib!journal.PagedJournal_v.JournalRecord.) core!option.Option.)
(declare-fun lib!spec.AsyncDisk_t.Address./Address/au (lib!spec.AsyncDisk_t.Address.) Int)
(declare-fun lib!spec.AsyncDisk_t.Address./Address/page (lib!spec.AsyncDisk_t.Address.) Int)
(declare-fun lib!spec.KeyType_t.Key./Key/0 (lib!spec.KeyType_t.Key.) Int)
(declare-fun lib!spec.Messages_t.Value./Value/0 (lib!spec.Messages_t.Value.) Int)
(declare-fun lib!spec.Messages_t.Delta./Delta/0 (lib!spec.Messages_t.Delta.) Int)
(declare-fun lib!spec.Messages_t.Message./Define/value (lib!spec.Messages_t.Message.) lib!spec.Messages_t.Value.)
(declare-fun lib!spec.Messages_t.Message./Update/delta (lib!spec.Messages_t.Message.) lib!spec.Messages_t.Delta.)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%core!option.Option. (Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%lib!abstract_system.MsgHistory_v.KeyedMessage. Type)
(declare-const TYPE%lib!abstract_system.MsgHistory_v.MsgHistory. Type)
(declare-const TYPE%lib!journal.LinkedJournal_v.JournalRecord. Type)
(declare-const TYPE%lib!journal.LinkedJournal_v.DiskView. Type)
(declare-const TYPE%lib!journal.LinkedJournal_v.TruncatedJournal. Type)
(declare-const TYPE%lib!journal.PagedJournal_v.JournalRecord. Type)
(declare-const TYPE%lib!spec.AsyncDisk_t.Address. Type)
(declare-const TYPE%lib!spec.KeyType_t.Key. Type)
(declare-const TYPE%lib!spec.Messages_t.Value. Type)
(declare-const TYPE%lib!spec.Messages_t.Delta. Type)
(declare-const TYPE%lib!spec.Messages_t.Message. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>. (vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>.) Poly)
(declare-fun %Poly%vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>. (Poly) vstd!map.Map<nat./lib!abstract_system.MsgHistory_v.KeyedMessage.>.)
(declare-fun Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (Poly) vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>.)
(declare-fun Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>.) Poly)
(declare-fun %Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (Poly) vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>.)
(declare-fun Poly%vstd!set.Set<nat.>. (vstd!set.Set<nat.>.) Poly)
(declare-fun %Poly%vstd!set.Set<nat.>. (Poly) vstd!set.Set<nat.>.)
(declare-fun Poly%vstd!set.Set<lib!spec.AsyncDisk_t.Address.>. (vstd!set.Set<lib!spec.AsyncDisk_t.Address.>.) Poly)
(declare-fun %Poly%vstd!set.Set<lib!spec.AsyncDisk_t.Address.>. (Poly) vstd!set.Set<lib!spec.AsyncDisk_t.Address.>.)
(declare-fun Poly%allocator_global%. (allocator_global%.) Poly)
(declare-fun %Poly%allocator_global%. (Poly) allocator_global%.)
(declare-fun Poly%core!option.Option. (core!option.Option.) Poly)
(declare-fun %Poly%core!option.Option. (Poly) core!option.Option.)
(declare-fun Poly%lib!abstract_system.MsgHistory_v.KeyedMessage. (lib!abstract_system.MsgHistory_v.KeyedMessage.) Poly)
(declare-fun %Poly%lib!abstract_system.MsgHistory_v.KeyedMessage. (Poly) lib!abstract_system.MsgHistory_v.KeyedMessage.)
(declare-fun Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (lib!abstract_system.MsgHistory_v.MsgHistory.) Poly)
(declare-fun %Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (Poly) lib!abstract_system.MsgHistory_v.MsgHistory.)
(declare-fun Poly%lib!journal.LinkedJournal_v.JournalRecord. (lib!journal.LinkedJournal_v.JournalRecord.) Poly)
(declare-fun %Poly%lib!journal.LinkedJournal_v.JournalRecord. (Poly) lib!journal.LinkedJournal_v.JournalRecord.)
(declare-fun Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.DiskView.) Poly)
(declare-fun %Poly%lib!journal.LinkedJournal_v.DiskView. (Poly) lib!journal.LinkedJournal_v.DiskView.)
(declare-fun Poly%lib!journal.LinkedJournal_v.TruncatedJournal. (lib!journal.LinkedJournal_v.TruncatedJournal.) Poly)
(declare-fun %Poly%lib!journal.LinkedJournal_v.TruncatedJournal. (Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun Poly%lib!journal.PagedJournal_v.JournalRecord. (lib!journal.PagedJournal_v.JournalRecord.) Poly)
(declare-fun %Poly%lib!journal.PagedJournal_v.JournalRecord. (Poly) lib!journal.PagedJournal_v.JournalRecord.)
(declare-fun Poly%lib!spec.AsyncDisk_t.Address. (lib!spec.AsyncDisk_t.Address.) Poly)
(declare-fun %Poly%lib!spec.AsyncDisk_t.Address. (Poly) lib!spec.AsyncDisk_t.Address.)
(declare-fun Poly%lib!spec.KeyType_t.Key. (lib!spec.KeyType_t.Key.) Poly)
(declare-fun %Poly%lib!spec.KeyType_t.Key. (Poly) lib!spec.KeyType_t.Key.)
(declare-fun Poly%lib!spec.Messages_t.Value. (lib!spec.Messages_t.Value.) Poly)
(declare-fun %Poly%lib!spec.Messages_t.Value. (Poly) lib!spec.Messages_t.Value.)
(declare-fun Poly%lib!spec.Messages_t.Delta. (lib!spec.Messages_t.Delta.) Poly)
(declare-fun %Poly%lib!spec.Messages_t.Delta. (Poly) lib!spec.Messages_t.Delta.)
(declare-fun Poly%lib!spec.Messages_t.Message. (lib!spec.Messages_t.Message.) Poly)
(declare-fun %Poly%lib!spec.Messages_t.Message. (Poly) lib!spec.Messages_t.Message.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (= x (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT))))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.)) (= x (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))))))
(assert (forall ((x vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>.)) (! (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.)) :pattern ((has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))))))
;(assert (forall ((x core!option.Option.)) (! (= x (%Poly%core!option.Option. (Poly%core!option.Option. x))) :pattern ((Poly%core!option.Option. x)))))
;(assert (forall ((V&. Dcr) (V& Type)) (! (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&)) :pattern ((has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. V&. V&))))))
(assert (forall ((V&. Dcr) (V& Type) (x Poly)) (! (=> (has_type x (TYPE%core!option.Option. V&. V&)) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. x)) V&)) :pattern ((core!option.Option./Some/0 (%Poly%core!option.Option. x)) (has_type x (TYPE%core!option.Option. V&. V&))))))

;(define-fun is-core!option.Option./Some_ ((c core!option.Option.)) Bool ((_ is core!option.Option./Some) c))



;(define-fun is-core!option.Option./None_ ((c core!option.Option.)) Bool ((_ is core!option.Option./None) c))


(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!journal.LinkedJournal_v.JournalRecord.) (has_type (Poly%core!option.Option. (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/prior_rec (%Poly%lib!journal.LinkedJournal_v.JournalRecord. x))) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) :pattern ((lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/prior_rec (%Poly%lib!journal.LinkedJournal_v.JournalRecord. x)) (has_type x TYPE%lib!journal.LinkedJournal_v.JournalRecord.)))))
;(assert (forall ((x lib!journal.LinkedJournal_v.DiskView.)) (! (= x (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. x))) :pattern ((Poly%lib!journal.LinkedJournal_v.DiskView. x)))))
;(assert (forall ((x lib!journal.LinkedJournal_v.DiskView.)) (! (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn x) (lib!journal.LinkedJournal_v.DiskView./DiskView/?boundary_lsn x)) :pattern ((lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn x)))))
;(assert (forall ((x lib!journal.LinkedJournal_v.DiskView.)) (! (= (lib!journal.LinkedJournal_v.DiskView./DiskView/entries x) (lib!journal.LinkedJournal_v.DiskView./DiskView/?entries x)) :pattern ((lib!journal.LinkedJournal_v.DiskView./DiskView/entries x)))))

;(define-fun is-lib!journal.PagedJournal_v.JournalRecord./JournalRecord_ ((c lib!journal.PagedJournal_v.JournalRecord.)) Bool ((_ is lib!journal.PagedJournal_v.JournalRecord./JournalRecord) c))


;(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec.AsyncDisk_t.Address.) (= x (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. x)))) :pattern ((has_type x TYPE%lib!spec.AsyncDisk_t.Address.)))))
(declare-fun tr_bound%vstd!std_specs.option.OptionAdditionalFns. (Dcr Type Dcr Type) Bool)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_Some.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.is_Some%default%.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.get_Some_0.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.OptionAdditionalFns.get_Some_0%default%.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!std_specs.option.spec_unwrap.? (Dcr Type Poly) Poly)
(declare-fun vstd!map.impl&%0.empty.? (Dcr Type Dcr Type) Poly)
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.insert.? (Dcr Type Dcr Type Poly Poly Poly) Poly)
(declare-fun vstd!map.impl&%0.remove.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.empty.? (Dcr Type) Poly)
(declare-fun vstd!set.impl&%0.insert.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.remove.? (Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.mk_map.? (Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.subset_of.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!map_lib.impl&%0.contains_key.? (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun vstd!map.impl&%0.new.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.contains.? (Poly Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.contains_exactly.? (Poly Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.wf.? (Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.can_follow.? (Poly Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.can_concat.? (Poly Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.can_discard_to.? (Poly Poly) Bool)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.discard_old.? (Poly Poly) lib!abstract_system.MsgHistory_v.MsgHistory.)
(declare-fun lib!abstract_system.MsgHistory_v.impl&%0.is_empty.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%0.wf.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.entries_wf.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (Poly Poly) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.this_block_can_concat.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%0.has_link.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.blocks_each_have_link.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.block_in_bounds.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.wf.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.seq_start.? (Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.seq_start.? (Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.seq_end.? (Poly Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.seq_end.? (Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.decodable.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.next.? (Poly Poly) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.can_crop.? (Poly Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.rec%can_crop.? (Poly Poly Poly Fuel) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop.? (Poly Poly Poly) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.rec%pointer_after_crop.? (Poly Poly Poly Fuel) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.can_crop.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.crop.? (Poly Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.can_discard_to.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.discard_old.? (Poly Poly) lib!journal.LinkedJournal_v.DiskView.)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.discard_old.? (Poly Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly) vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly Poly) lib!journal.LinkedJournal_v.DiskView.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly Poly Fuel) lib!journal.LinkedJournal_v.DiskView.)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.build_tight.? (Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun vstd!map_lib.impl&%0.submap_of.? (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun vstd!map_lib.impl&%0.spec_le.? (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.valid_discard_old.? (Poly Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%3.bounded_discard.? (Poly Poly) lib!abstract_system.MsgHistory_v.MsgHistory.)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.append_record.? (Poly Poly Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun vstd!math.max.? (Poly Poly) Int)
(declare-fun lib!journal.LinkedJournal_v.impl&%0.contains_lsn.? (Poly Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.mkfs.? (Poly) lib!journal.LinkedJournal_v.TruncatedJournal.)
(declare-fun vstd!map.check_argument_is_map.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.iptr.? (Poly Poly) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.rec%iptr.? (Poly Poly Fuel) core!option.Option.)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.is_sub_disk_with_newer_lsn.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.is_tight.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.lsn_has_entry_at.? (Poly Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.lsn_has_entry.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%1.lsns_have_entries.? (Poly Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.lsns_have_entries.? (Poly) Bool)
(declare-fun lib!journal.LinkedJournal_v.impl&%2.marshal_ranking.? (Poly Poly) vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>.)
(declare-fun req%vstd!std_specs.option.spec_unwrap. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (has_type (vstd!map.impl&%0.empty.? K&. K& V&. V&) (TYPE%vstd!map.Map. K&. K& V&. V&)) :pattern ((vstd!map.impl&%0.empty.? K&. K& V&. V&)))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self!)))))
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (has_type (vstd!map.impl&%0.insert.? K&. K& V&. V& self! key! value!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.insert.? K&. K& V&. V& self! key! value!)))))
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_empty.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&)) (vstd!set.impl&%0.empty.? K&. K&)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&)))))))
(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_domain.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!)) (vstd!set.impl&%0.insert.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key!))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!)))))))
;(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_same.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&) (has_type value! V&)) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!) key!) value!)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key! value!) key!))))))
;(assert (=> (fuel_bool fuel%vstd!map.axiom_map_insert_different.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m! Poly) (key1! Poly) (key2! Poly) (value! Poly)) (! (=> (and (has_type m! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key1! K&) (has_type key2! K&) (has_type value! V&)) (=> (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m!) key1!) (not (= key1! key2!))) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key2! value!) key1!) (vstd!map.impl&%0.index.? K&. K& V&. V& m! key1!)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m! key2! value!) key1!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_empty.) (forall ((A&. Dcr) (A& Type) (a! Poly)) (! (=> (has_type a! A&) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_insert_different.) (forall ((A&. Dcr) (A& Type) (s! Poly) (a1! Poly) (a2! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. A&. A&)) (has_type a1! A&) (has_type a2! A&)) (=> (not (= a1! a2!)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!) (vstd!set.impl&%0.contains.? A&. A& s! a1!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s! a2!) a1!))))))
(declare-fun req%lib!abstract_system.MsgHistory_v.impl&%0.discard_old. (Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(declare-fun %%lambda%%0 (Int Int) %%Function%%)
(declare-fun %%lambda%%1 (Dcr Type Dcr Type Poly) %%Function%%)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? self! ptr!) (=> ((_ is core!option.Option./Some) (%Poly%core!option.Option. ptr!)) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. ptr!))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? self! ptr!))))))
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.) (forall ((self! Poly) (boundary_lsn! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? self! boundary_lsn!) (ite (< (%I boundary_lsn!) (lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/seq_start (%Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/message_seq (%Poly%lib!journal.LinkedJournal_v.JournalRecord. self!)))))) (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/prior_rec (%Poly%lib!journal.LinkedJournal_v.JournalRecord. self!)) core!option.Option./None)) :pattern ((lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? self! boundary_lsn!))))))
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.) (forall ((self! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? self!) (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) addr$) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? self! (Poly%core!option.Option. (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) addr$) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) addr$))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? self!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.this_block_can_concat. (Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(declare-const %%global_location_label%%5 Bool)
(declare-const %%global_location_label%%6 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat. (Poly) Bool)
(declare-const %%global_location_label%%7 Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.wf.))
;(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.wf.) (forall ((self! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.wf.? self!) (and (and (and (lib!journal.LinkedJournal_v.impl&%1.entries_wf.? self!) (lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? self!)) (lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat.? self!)) (lib!journal.LinkedJournal_v.impl&%1.blocks_each_have_link.? self!))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.wf.? self!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.seq_end. (Poly Poly) Bool)
(declare-const %%global_location_label%%9 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.seq_end. (Poly) Bool)
(declare-const %%global_location_label%%10 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.valid_ranking. (Poly Poly) Bool)
(declare-const %%global_location_label%%11 Bool)
;(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.))
(assert (=> true (forall ((self! Poly) (ranking! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? self! ranking!) (and (vstd!set.impl&%0.subset_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT ranking!)) (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (and (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) addr$) ((_ is core!option.Option./Some) (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) addr$) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))) (< (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT ranking! (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) addr$) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))))) (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT ranking! addr$))))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) addr$)))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? self! ranking!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.acyclic. (Poly) Bool)
(declare-const %%global_location_label%%12 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.) (forall ((self! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.acyclic.? self!) (exists ((ranking$ Poly)) (! (and (has_type ranking$ (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? self! ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? self! ranking$))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.acyclic.? self!))))))
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.decodable.? self! ptr!) (and (lib!journal.LinkedJournal_v.impl&%1.wf.? self!) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? self! ptr!))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.decodable.? self! ptr!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.next. (Poly Poly) Bool)
(declare-const %%global_location_label%%13 Bool)
(declare-const %%global_location_label%%14 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.next.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.next.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.next.? self! ptr!) (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. ptr!))) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.next.? self! ptr!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.can_crop. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%15 Bool)
(declare-const %%global_location_label%%16 Bool)
(declare-const fuel_nat%lib!journal.LinkedJournal_v.impl&%1.can_crop. Fuel)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%17 Bool)
(declare-const %%global_location_label%%18 Bool)
(declare-const %%global_location_label%%19 Bool)
(declare-const fuel_nat%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop. Fuel)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.crop. (Poly Poly) Bool)
(declare-const %%global_location_label%%20 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.can_discard_to. (Poly Poly) Bool)
(declare-const %%global_location_label%%21 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.discard_old. (Poly Poly) Bool)
(declare-const %%global_location_label%%22 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.discard_old. (Poly Poly) Bool)
(declare-const %%global_location_label%%23 Bool)
(declare-const %%global_location_label%%24 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.the_ranking. (Poly) Bool)
(declare-const %%global_location_label%%25 Bool)
(declare-const %%global_location_label%%26 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.))
(declare-fun %%choose%%0 (Type Poly Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Poly) (%%hole%%2 Poly)) (! (=> (exists ((ranking$ Poly)) (! (and (has_type ranking$ %%hole%%0) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? %%hole%%1 ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? %%hole%%2 ranking$)))) (exists ((ranking$ Poly)) (! (and (and (has_type ranking$ %%hole%%0) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? %%hole%%1 ranking$)) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2) ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? %%hole%%2 ranking$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2)))))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.) (forall ((self! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? self!) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (as_type (%%choose%%0 (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT) self! self!) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.the_ranking.? self!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.the_rank_of. (Poly Poly) Bool)
(declare-const %%global_location_label%%27 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.) (forall ((self! Poly) (ptr! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? self! ptr!) (ite (and ((_ is core!option.Option./Some) (%Poly%core!option.Option. ptr!)) (lib!journal.LinkedJournal_v.impl&%1.acyclic.? self!)) (nClip (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? self!)) (core!option.Option./Some/0 (%Poly%core!option.Option. ptr!)))) 1)) 0)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? self! ptr!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.build_tight. (Poly Poly) Bool)
(declare-const %%global_location_label%%28 Bool)
(declare-const %%global_location_label%%29 Bool)
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.))
(declare-const fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight. Fuel)
(assert (forall ((self! Poly) (root! Poly) (fuel% Fuel)) (! (= (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! fuel%) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! zero)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! fuel%)))))
(assert (forall ((self! Poly) (root! Poly) (fuel% Fuel)) (! (=> (and (has_type self! TYPE%lib!journal.LinkedJournal_v.DiskView.) (has_type root! (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.)) (lib!journal.LinkedJournal_v.impl&%1.decodable.? self! root!)) (= (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! (succ fuel%)) (ite (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? self!)) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I 0)) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.empty.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (ite ((_ is core!option.Option./None) (%Poly%core!option.Option. root!)) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.empty.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (let ((addr$ (%Poly%lib!spec.AsyncDisk_t.Address. (core!option.Option./Some/0 (%Poly%core!option.Option. root!))))) (let ((tail$ (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! (Poly%core!option.Option. (lib!journal.LinkedJournal_v.impl&%1.next.? self! root!)) fuel%))) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.insert.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. tail$)))) (Poly%lib!spec.AsyncDisk_t.Address. addr$) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (Poly%lib!spec.AsyncDisk_t.Address. addr$))))))))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! (succ fuel%))))))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.) (forall ((self! Poly) (root! Poly)) (! (=> (and (has_type self! TYPE%lib!journal.LinkedJournal_v.DiskView.) (has_type root! (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.)) (lib!journal.LinkedJournal_v.impl&%1.decodable.? self! root!)) (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? self! root!) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? self! root! (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.build_tight.? self! root!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.build_tight. (Poly) Bool)
(declare-const %%global_location_label%%30 Bool)
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.submap_of.))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.submap_of.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (m2! Poly)) (! (= (vstd!map_lib.impl&%0.submap_of.? K&. K& V&. V& self! m2!) (forall ((k$ Poly)) (! (=> (has_type k$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) k$) (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!) k$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& self! k$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2! k$))))) :pattern ((vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) k$) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!) k$))))) :pattern ((vstd!map_lib.impl&%0.submap_of.? K&. K& V&. V& self! m2!))))))
(assert (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.))
(assert (=> (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.) (forall ((self! Poly) (bigger! Poly)) (! (= (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? self! bigger!) (and (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. bigger!)) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. bigger!)))))) :pattern ((lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? self! bigger!))))))
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.valid_discard_old. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%31 Bool)
(declare-const %%global_location_label%%32 Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.iptr. (Poly Poly) Bool)
(declare-const %%global_location_label%%33 Bool)
(declare-const %%global_location_label%%34 Bool)
(declare-const %%global_location_label%%35 Bool)
(declare-const fuel_nat%lib!journal.LinkedJournal_v.impl&%1.iptr. Fuel)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.marshal_ranking. (Poly Poly) Bool)
(declare-const %%global_location_label%%36 Bool)
(declare-fun ens%lib!journal.LinkedJournal_v.impl&%2.mkfs_ensures. (Int) Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop_seq_end. (lib!journal.LinkedJournal_v.DiskView. core!option.Option. Int) Bool)
(declare-const %%global_location_label%%37 Bool)
(declare-const %%global_location_label%%38 Bool)
(declare-const %%global_location_label%%39 Bool)
(declare-fun ens%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop_seq_end. (lib!journal.LinkedJournal_v.DiskView. core!option.Option. Int) Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop_ensures. (lib!journal.LinkedJournal_v.DiskView. core!option.Option. Int) Bool)
(declare-const %%global_location_label%%40 Bool)
(declare-const %%global_location_label%%41 Bool)
(declare-const %%global_location_label%%42 Bool)
(declare-fun ens%lib!journal.LinkedJournal_v.impl&%1.pointer_after_crop_ensures. (lib!journal.LinkedJournal_v.DiskView. core!option.Option. Int) Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%2.crop_ensures. (lib!journal.LinkedJournal_v.TruncatedJournal. Int) Bool)
(declare-const %%global_location_label%%43 Bool)
(declare-fun ens%lib!journal.LinkedJournal_v.impl&%2.crop_ensures. (lib!journal.LinkedJournal_v.TruncatedJournal. Int) Bool)
(declare-fun req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. (lib!journal.LinkedJournal_v.DiskView. core!option.Option.) Bool)
(declare-const %%global_location_label%%44 Bool)
(assert (forall ((self! lib!journal.LinkedJournal_v.DiskView.) (root! core!option.Option.)) (! (= (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! root!) (=> %%global_location_label%%44 (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))) :pattern ((req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! root!)))))
(declare-fun ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. (lib!journal.LinkedJournal_v.DiskView. core!option.Option.) Bool)
(assert (forall ((self! lib!journal.LinkedJournal_v.DiskView.) (root! core!option.Option.)) (! (= (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! root!) (and (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) addr$)))) (=> (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) :pattern ((ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! root!)))))
(declare-const self! lib!journal.LinkedJournal_v.DiskView.)
(declare-const root! core!option.Option.)
(declare-const tmp%1 core!option.Option.)
(declare-const decrease%init0 Int)
(assert fuel_defaults)
(assert (has_type (Poly%lib!journal.LinkedJournal_v.DiskView. self!) TYPE%lib!journal.LinkedJournal_v.DiskView.))
(assert (has_type (Poly%core!option.Option. root!) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.)))
(assert (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))
(declare-const %%switch_label%%0 Bool)
(declare-const %%switch_label%%1 Bool)
(declare-const %%location_label%%0 Bool)
(declare-const %%location_label%%1 Bool)
(declare-const %%location_label%%2 Bool)
(declare-const %%location_label%%3 Bool)
(assert (not (=> (= decrease%init0 (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (or (and (=> (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) %%switch_label%%0) (=> (not (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (or (and (=> ((_ is core!option.Option./None) root!) %%switch_label%%1) (=> (not ((_ is core!option.Option./None) root!)) (=> (= tmp%1 (lib!journal.LinkedJournal_v.impl&%1.next.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (and (=> %%location_label%%0 (check_decrease_int (let ((self!$0 self!) (root!$1 tmp%1)) (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!$0) (Poly%core!option.Option. root!$1))) decrease%init0 false)) (and (=> %%location_label%%1 (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1)) (=> (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1) %%switch_label%%1)))))) (and (not %%switch_label%%1) %%switch_label%%0)))) (and (not %%switch_label%%0) (and (=> %%location_label%%2 (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) addr$))))) (=> %%location_label%%3 (=> (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_empty.)) (fuel_bool_default fuel%vstd!map.axiom_map_empty.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_empty.)) (fuel_bool fuel%vstd!map.axiom_map_empty.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_domain.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.)) (fuel_bool fuel%vstd!map.axiom_map_insert_domain.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_same.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.)) (fuel_bool fuel%vstd!map.axiom_map_insert_same.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_different.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.)) (fuel_bool fuel%vstd!map.axiom_map_insert_different.))))
        (assert (and (or (not (fuel_bool fuel%vstd!set.axiom_set_empty.)) (fuel_bool_default fuel%vstd!set.axiom_set_empty.)) (or (not (fuel_bool_default fuel%vstd!set.axiom_set_empty.)) (fuel_bool fuel%vstd!set.axiom_set_empty.))))
        (assert (and (or (not (fuel_bool fuel%vstd!set.axiom_set_insert_different.)) (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.)) (or (not (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.)) (fuel_bool fuel%vstd!set.axiom_set_insert_different.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.wf.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.next.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map_lib.impl&%0.submap_of.)) (fuel_bool_default fuel%vstd!map_lib.impl&%0.submap_of.)) (or (not (fuel_bool_default fuel%vstd!map_lib.impl&%0.submap_of.)) (fuel_bool fuel%vstd!map_lib.impl&%0.submap_of.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.))))
        (assert (and (or (not (check_decrease_int (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0 false)) (and (<= 0 (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (< (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0)) (and (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0) false)) (or (and (or (not (<= 0 (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))) (not (< (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0))) (or (not (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0)) true)) (check_decrease_int (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0 false))))
        (assert (= root! (%Poly%core!option.Option. (Poly%core!option.Option. root!))))
        (assert (has_type (Poly%core!option.Option. core!option.Option./None) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.)))
        (assert (= self! (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)) (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (exists ((ranking$ Poly)) (! (and (has_type ranking$ (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$))))) (or (not (exists ((ranking$ Poly)) (! (and (has_type ranking$ (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$))))) (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (and (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.next.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)) (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)) (ite (and ((_ is core!option.Option./Some) (%Poly%core!option.Option. (Poly%core!option.Option. root!))) (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (nClip (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1)) 0)))
        (assert (or (not (has_type (Poly%lib!journal.LinkedJournal_v.DiskView. self!) TYPE%lib!journal.LinkedJournal_v.DiskView.)) (not (has_type (Poly%core!option.Option. root!) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!) (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (and (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))) (or (not (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) (not (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1)) (not %%global_location_label%%44) (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (or (and %%global_location_label%%44 (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))) (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1))))
        (assert (and (or (not (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1)) (and (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (or (not (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$))))) (and (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (not (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1))))
(declare-const skolem_variable_0 Poly)
(declare-const skolem_variable_1 Poly)

(assert (and (has_type skolem_variable_0 TYPE%lib!spec.AsyncDisk_t.Address.) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) skolem_variable_0) (not (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) skolem_variable_0))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_empty.)) (fuel_bool_default fuel%vstd!map.axiom_map_empty.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_empty.)) (fuel_bool fuel%vstd!map.axiom_map_empty.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_domain.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_domain.)) (fuel_bool fuel%vstd!map.axiom_map_insert_domain.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_same.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_same.)) (fuel_bool fuel%vstd!map.axiom_map_insert_same.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map.axiom_map_insert_different.)) (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.)) (or (not (fuel_bool_default fuel%vstd!map.axiom_map_insert_different.)) (fuel_bool fuel%vstd!map.axiom_map_insert_different.))))
        (assert (and (or (not (fuel_bool fuel%vstd!set.axiom_set_empty.)) (fuel_bool_default fuel%vstd!set.axiom_set_empty.)) (or (not (fuel_bool_default fuel%vstd!set.axiom_set_empty.)) (fuel_bool fuel%vstd!set.axiom_set_empty.))))
        (assert (and (or (not (fuel_bool fuel%vstd!set.axiom_set_insert_different.)) (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.)) (or (not (fuel_bool_default fuel%vstd!set.axiom_set_insert_different.)) (fuel_bool fuel%vstd!set.axiom_set_insert_different.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%0.cropped_prior.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.wf.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.wf.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.valid_ranking.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.acyclic.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.decodable.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.next.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.next.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_ranking.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.the_rank_of.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.build_tight.))))
        (assert (and (or (not (fuel_bool fuel%vstd!map_lib.impl&%0.submap_of.)) (fuel_bool_default fuel%vstd!map_lib.impl&%0.submap_of.)) (or (not (fuel_bool_default fuel%vstd!map_lib.impl&%0.submap_of.)) (fuel_bool fuel%vstd!map_lib.impl&%0.submap_of.))))
        (assert (and (or (not (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (or (not (fuel_bool_default fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.)) (fuel_bool fuel%lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.))))
        (assert (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))))
        (assert (and (<= 0 (nClip (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1))) (or (not (<= 0 (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1))) (= (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1) (nClip (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1))))))
        (assert (= (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1) (+ (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) 1)))
        (assert (and (or (not (check_decrease_int (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0 false)) (and (<= 0 (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (< (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0)) (and (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0) false)) (or (and (or (not (<= 0 (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))) (not (< (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0))) (or (not (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0)) true)) (check_decrease_int (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) decrease%init0 false))))
        (assert (= tmp%1 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%1))))
        (assert (or (not (has_type (Poly%core!option.Option. root!) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))) TYPE%lib!spec.AsyncDisk_t.Address.)))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))
        (assert (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/?boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))) (lib!journal.LinkedJournal_v.DiskView./DiskView/?boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))))
        (assert (= (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/?entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (= (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))) (lib!journal.LinkedJournal_v.DiskView./DiskView/?entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))))
        (assert (or (not (has_type skolem_variable_0 TYPE%lib!spec.AsyncDisk_t.Address.)) (= skolem_variable_0 (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. skolem_variable_0)))))
        (assert (or (not (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))) TYPE%lib!spec.AsyncDisk_t.Address.)) (= (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))) (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))))))
        (assert (or (not (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (has_type (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) (TYPE%vstd!set.Set. $ TYPE%lib!spec.AsyncDisk_t.Address.))))
        (assert (or (not (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (has_type (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (TYPE%vstd!set.Set. $ TYPE%lib!spec.AsyncDisk_t.Address.))))
        (assert (or (not (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (not (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))) TYPE%lib!spec.AsyncDisk_t.Address.)) (has_type (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))) TYPE%lib!journal.LinkedJournal_v.JournalRecord.)))
        (assert (or (not (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT))) (not (has_type (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))) TYPE%lib!spec.AsyncDisk_t.Address.)) (has_type (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))) NAT)))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (not ((_ is core!option.Option./Some) (%Poly%core!option.Option. (Poly%core!option.Option. root!)))) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) (or (and ((_ is core!option.Option./Some) (%Poly%core!option.Option. (Poly%core!option.Option. root!))) (not (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))))) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%0.cropped_prior.? (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))) (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (ite (< (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (lib!abstract_system.MsgHistory_v.MsgHistory./MsgHistory/seq_start (%Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (Poly%lib!abstract_system.MsgHistory_v.MsgHistory. (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/message_seq (%Poly%lib!journal.LinkedJournal_v.JournalRecord. (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))))))))) (lib!journal.LinkedJournal_v.JournalRecord./JournalRecord/prior_rec (%Poly%lib!journal.LinkedJournal_v.JournalRecord. (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!)))))) core!option.Option./None)))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (and (lib!journal.LinkedJournal_v.impl&%1.entries_wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.blocks_each_have_link.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.entries_wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.nondangling_pointers.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.blocks_can_concat.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.blocks_each_have_link.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (exists ((ranking$ Poly)) (! (and (has_type ranking$ (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$))))) (or (not (exists ((ranking$ Poly)) (! (and (has_type ranking$ (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$)) :pattern ((lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) ranking$))))) (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (and (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (and (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.wf.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (not (lib!journal.LinkedJournal_v.impl&%1.is_nondangling_pointer.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (as_type (%%choose%%0 (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT) (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)))))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.the_rank_of.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) (ite (and ((_ is core!option.Option./Some) (%Poly%core!option.Option. (Poly%core!option.Option. tmp%1))) (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (nClip (Add (%I (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./nat.>. (lib!journal.LinkedJournal_v.impl&%1.the_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. tmp%1))))) 1)) 0)))
        (assert (= (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!) (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!) zero)))
        (assert (or (not (has_type (Poly%lib!journal.LinkedJournal_v.DiskView. self!) TYPE%lib!journal.LinkedJournal_v.DiskView.)) (not (has_type (Poly%core!option.Option. root!) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (= (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!) (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)) (ite (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I 0)) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.empty.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (ite ((_ is core!option.Option./None) (%Poly%core!option.Option. (Poly%core!option.Option. root!))) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.empty.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord.))) (lib!journal.LinkedJournal_v.DiskView./DiskView (%I (I (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (%Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (vstd!map.impl&%0.insert.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. (lib!journal.LinkedJournal_v.impl&%1.next.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.))))) (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. (core!option.Option./Some/0 (%Poly%core!option.Option. (Poly%core!option.Option. root!))))))))))))))
        (assert (or (not (has_type (Poly%lib!journal.LinkedJournal_v.DiskView. self!) TYPE%lib!journal.LinkedJournal_v.DiskView.)) (not (has_type (Poly%core!option.Option. root!) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!) (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)))))
        (assert (or (not (has_type (Poly%lib!journal.LinkedJournal_v.DiskView. self!) TYPE%lib!journal.LinkedJournal_v.DiskView.)) (not (has_type (Poly%core!option.Option. tmp%1) (TYPE%core!option.Option. $ TYPE%lib!spec.AsyncDisk_t.Address.))) (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (= (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)) (lib!journal.LinkedJournal_v.impl&%1.rec%build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1) (succ fuel_nat%lib!journal.LinkedJournal_v.impl&%1.build_tight.)))))
        (assert (and (or (not (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))) (forall ((k$ Poly)) (! (=> (has_type k$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) k$) (and (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) k$) (= (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) k$) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) k$))))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) k$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) k$))))) (or (not (forall ((k$ Poly)) (! (=> (has_type k$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) k$) (and (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) k$) (= (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) k$) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) k$))))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) k$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) k$))))) (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (and (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))) (or (not (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))))))) (not (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. root!))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (and (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))))) (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))))) (or (not (= (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.DiskView./DiskView/boundary_lsn (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) (not (vstd!map_lib.impl&%0.submap_of.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))))) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))))
        (assert (and (or (not (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1)) (not %%global_location_label%%44) (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (or (and %%global_location_label%%44 (not (lib!journal.LinkedJournal_v.impl&%1.decodable.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1)))) (req%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1))))
        (assert (and (or (not (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1)) (and (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$)))) (or (not (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!))) (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) (or (not (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$) (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. self!))))) addr$))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ TYPE%lib!journal.LinkedJournal_v.JournalRecord. (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./lib!journal.LinkedJournal_v.JournalRecord.>. (lib!journal.LinkedJournal_v.DiskView./DiskView/entries (%Poly%lib!journal.LinkedJournal_v.DiskView. (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))))))) addr$))))) (and (lib!journal.LinkedJournal_v.impl&%1.acyclic.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!)) (not (lib!journal.LinkedJournal_v.impl&%1.is_sub_disk.? (Poly%lib!journal.LinkedJournal_v.DiskView. (lib!journal.LinkedJournal_v.impl&%1.build_tight.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) (Poly%core!option.Option. tmp%1))) (Poly%lib!journal.LinkedJournal_v.DiskView. self!)))) (ens%lib!journal.LinkedJournal_v.impl&%1.build_tight_ensures. self! tmp%1))))
(assert (and (has_type skolem_variable_1 (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ NAT)) (lib!journal.LinkedJournal_v.impl&%1.valid_ranking.? (Poly%lib!journal.LinkedJournal_v.DiskView. self!) skolem_variable_1)))

(check-sat)
(exit)
