(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id))))))
(declare-sort Poly 0)
(declare-fun B (Bool) Poly)
(declare-fun %B (Poly) Bool)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun has_type (Poly Type) Bool)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)))))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)))))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)))))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(declare-const fuel%vstd!map.impl&%0.new. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.contains_value. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.values. FuelId)
(declare-const fuel%vstd!map_lib.impl&%0.union_prefer_right. FuelId)
(declare-const fuel%vstd!set.impl&%0.subset_of. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty. FuelId)
(declare-const fuel%vstd!set.axiom_set_new. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal. FuelId)
(declare-const fuel%vstd!set.axiom_set_ext_equal_deep. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_domain. FuelId)
(declare-const fuel%vstd!set.axiom_mk_map_index. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_finite. FuelId)
(declare-const fuel%vstd!set.axiom_set_empty_len. FuelId)
(declare-const fuel%vstd!set.axiom_set_contains_len. FuelId)
(declare-const fuel%lib!exec.Cache_v.Cache.impl&%5.access_strong. FuelId)
(declare-const fuel%lib!exec.Cache_v.Cache.impl&%5.invariant. FuelId)
(declare-const fuel%lib!exec.Cache_v.Cache.impl&%5.inv. FuelId)
(declare-const fuel%lib!exec.Cache_v.Cache.impl&%5.valid_write. FuelId)
(declare-const fuel%lib!exec.Cache_v.impl&%1.get_addr. FuelId)
(declare-const fuel%vstd!array.group_array_axioms. FuelId)
(declare-const fuel%vstd!map.group_map_axioms. FuelId)
(declare-const fuel%vstd!multiset.group_multiset_axioms. FuelId)
(declare-const fuel%vstd!raw_ptr.group_raw_ptr_axioms. FuelId)
(declare-const fuel%vstd!seq.group_seq_axioms. FuelId)
(declare-const fuel%vstd!seq_lib.group_seq_lib_default. FuelId)
(declare-const fuel%vstd!set.group_set_axioms. FuelId)
(declare-const fuel%vstd!set_lib.group_set_lib_axioms. FuelId)
(declare-const fuel%vstd!slice.group_slice_axioms. FuelId)
(declare-const fuel%vstd!string.group_string_axioms. FuelId)
(declare-const fuel%vstd!std_specs.bits.group_bits_axioms. FuelId)
(declare-const fuel%vstd!std_specs.control_flow.group_control_flow_axioms. FuelId)
(declare-const fuel%vstd!std_specs.range.group_range_axioms. FuelId)
(declare-const fuel%vstd!std_specs.vec.group_vec_axioms. FuelId)
(declare-const fuel%vstd!group_vstd_default. FuelId)
(assert (=> (fuel_bool_default fuel%vstd!set.group_set_axioms.) (and (fuel_bool_default fuel%vstd!set.axiom_set_empty.) (fuel_bool_default fuel%vstd!set.axiom_set_new.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal.) (fuel_bool_default fuel%vstd!set.axiom_set_ext_equal_deep.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_domain.) (fuel_bool_default fuel%vstd!set.axiom_mk_map_index.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_finite.) (fuel_bool_default fuel%vstd!set.axiom_set_empty_len.) (fuel_bool_default fuel%vstd!set.axiom_set_contains_len.))))
(assert (fuel_bool_default fuel%vstd!group_vstd_default.))
(assert (=> (fuel_bool_default fuel%vstd!group_vstd_default.) (and (fuel_bool_default fuel%vstd!seq.group_seq_axioms.) (fuel_bool_default fuel%vstd!seq_lib.group_seq_lib_default.) (fuel_bool_default fuel%vstd!map.group_map_axioms.) (fuel_bool_default fuel%vstd!set.group_set_axioms.) (fuel_bool_default fuel%vstd!set_lib.group_set_lib_axioms.) (fuel_bool_default fuel%vstd!std_specs.bits.group_bits_axioms.) (fuel_bool_default fuel%vstd!std_specs.control_flow.group_control_flow_axioms.) (fuel_bool_default fuel%vstd!std_specs.vec.group_vec_axioms.) (fuel_bool_default fuel%vstd!slice.group_slice_axioms.) (fuel_bool_default fuel%vstd!array.group_array_axioms.) (fuel_bool_default fuel%vstd!multiset.group_multiset_axioms.) (fuel_bool_default fuel%vstd!string.group_string_axioms.) (fuel_bool_default fuel%vstd!std_specs.range.group_range_axioms.) (fuel_bool_default fuel%vstd!raw_ptr.group_raw_ptr_axioms.))))
(declare-sort vstd!map.Map<u64./lib!spec.AsyncDisk_t.DiskRequest.>. 0)
(declare-sort vstd!map.Map<u64./lib!spec.AsyncDisk_t.DiskResponse.>. 0)
(declare-sort vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. 0)
(declare-sort vstd!map.Map<i32./lib!exec.Cache_v.Status.>. 0)
(declare-sort vstd!map.Map<i32./lib!spec.AsyncDisk_t.Address.>. 0)
(declare-sort vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. 0)
(declare-sort vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. 0)
(declare-sort vstd!seq.Seq<u8.>. 0)
(declare-sort vstd!set.Set<i32.>. 0)
(declare-datatypes ((lib!exec.Cache_v.Cache.State. 0) (lib!exec.Cache_v.Cache.Step. 0) (lib!exec.Cache_v.Cache.Config. 0) (lib!exec.Cache_v.Cache.Label. 0) (lib!spec.AsyncDisk_t.Address. 0) (lib!spec.AsyncDisk_t.DiskRequest. 0) (lib!spec.AsyncDisk_t.DiskResponse. 0) (lib!exec.Cache_v.Status. 0) (lib!exec.Cache_v.Entry. 0) (tuple%0. 0) (tuple%2. 0)) (((lib!exec.Cache_v.Cache.State./State (lib!exec.Cache_v.Cache.State./State/?entries vstd!map.Map<i32./lib!exec.Cache_v.Entry.>.) (lib!exec.Cache_v.Cache.State./State/?status_map vstd!map.Map<i32./lib!exec.Cache_v.Status.>.) (lib!exec.Cache_v.Cache.State./State/?lookup_map vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>.))) ((lib!exec.Cache_v.Cache.Step./reserve (lib!exec.Cache_v.Cache.Step./reserve/?0 vstd!map.Map<i32./lib!spec.AsyncDisk_t.Address.>.)) (lib!exec.Cache_v.Cache.Step./load_initiate (lib!exec.Cache_v.Cache.Step./load_initiate/?0 vstd!map.Map<i32./lib!spec.AsyncDisk_t.Address.>.)) (lib!exec.Cache_v.Cache.Step./load_complete) (lib!exec.Cache_v.Cache.Step./access) (lib!exec.Cache_v.Cache.Step./writeback_initiate) (lib!exec.Cache_v.Cache.Step./writeback_complete) (lib!exec.Cache_v.Cache.Step./evict (lib!exec.Cache_v.Cache.Step./evict/?0 vstd!set.Set<i32.>.)) (lib!exec.Cache_v.Cache.Step./noop) (lib!exec.Cache_v.Cache.Step./dummy_to_use_type_params (lib!exec.Cache_v.Cache.Step./dummy_to_use_type_params/?0 lib!exec.Cache_v.Cache.State.))) ((lib!exec.Cache_v.Cache.Config./initialize (lib!exec.Cache_v.Cache.Config./initialize/?0 Int)) (lib!exec.Cache_v.Cache.Config./dummy_to_use_type_params (lib!exec.Cache_v.Cache.Config./dummy_to_use_type_params/?0 lib!exec.Cache_v.Cache.State.))) ((lib!exec.Cache_v.Cache.Label./Access (lib!exec.Cache_v.Cache.Label./Access/?reads vstd!map.Map<i32./vstd!seq.Seq<u8.>.>.) (lib!exec.Cache_v.Cache.Label./Access/?writes vstd!map.Map<i32./vstd!seq.Seq<u8.>.>.)) (lib!exec.Cache_v.Cache.Label./DiskOps (lib!exec.Cache_v.Cache.Label./DiskOps/?requests vstd!map.Map<u64./lib!spec.AsyncDisk_t.DiskRequest.>.) (lib!exec.Cache_v.Cache.Label./DiskOps/?responses vstd!map.Map<u64./lib!spec.AsyncDisk_t.DiskResponse.>.)) (lib!exec.Cache_v.Cache.Label./Internal)) ((lib!spec.AsyncDisk_t.Address./Address (lib!spec.AsyncDisk_t.Address./Address/?au Int) (lib!spec.AsyncDisk_t.Address./Address/?page Int))) ((lib!spec.AsyncDisk_t.DiskRequest./ReadReq (lib!spec.AsyncDisk_t.DiskRequest./ReadReq/?from lib!spec.AsyncDisk_t.Address.)) (lib!spec.AsyncDisk_t.DiskRequest./WriteReq (lib!spec.AsyncDisk_t.DiskRequest./WriteReq/?to lib!spec.AsyncDisk_t.Address.) (lib!spec.AsyncDisk_t.DiskRequest./WriteReq/?data vstd!seq.Seq<u8.>.))) ((lib!spec.AsyncDisk_t.DiskResponse./ReadResp (lib!spec.AsyncDisk_t.DiskResponse./ReadResp/?from lib!spec.AsyncDisk_t.Address.) (lib!spec.AsyncDisk_t.DiskResponse./ReadResp/?data vstd!seq.Seq<u8.>.)) (lib!spec.AsyncDisk_t.DiskResponse./WriteResp (lib!spec.AsyncDisk_t.DiskResponse./WriteResp/?to lib!spec.AsyncDisk_t.Address.))) ((lib!exec.Cache_v.Status./NotFilled) (lib!exec.Cache_v.Status./Clean) (lib!exec.Cache_v.Status./Dirty) (lib!exec.Cache_v.Status./Writeback)) ((lib!exec.Cache_v.Entry./Empty) (lib!exec.Cache_v.Entry./Reserved (lib!exec.Cache_v.Entry./Reserved/?addr lib!spec.AsyncDisk_t.Address.)) (lib!exec.Cache_v.Entry./Loading (lib!exec.Cache_v.Entry./Loading/?addr lib!spec.AsyncDisk_t.Address.)) (lib!exec.Cache_v.Entry./Filled (lib!exec.Cache_v.Entry./Filled/?addr lib!spec.AsyncDisk_t.Address.) (lib!exec.Cache_v.Entry./Filled/?data vstd!seq.Seq<u8.>.))) ((tuple%0./tuple%0)) ((tuple%2./tuple%2 (tuple%2./tuple%2/?0 Poly) (tuple%2./tuple%2/?1 Poly)))))
(declare-fun lib!exec.Cache_v.Cache.State./State/entries (lib!exec.Cache_v.Cache.State.) vstd!map.Map<i32./lib!exec.Cache_v.Entry.>.)
(declare-fun lib!exec.Cache_v.Cache.State./State/status_map (lib!exec.Cache_v.Cache.State.) vstd!map.Map<i32./lib!exec.Cache_v.Status.>.)
(declare-fun lib!exec.Cache_v.Cache.State./State/lookup_map (lib!exec.Cache_v.Cache.State.) vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>.)
(declare-fun lib!exec.Cache_v.Cache.Label./Access/reads (lib!exec.Cache_v.Cache.Label.) vstd!map.Map<i32./vstd!seq.Seq<u8.>.>.)
(declare-fun lib!exec.Cache_v.Cache.Label./Access/writes (lib!exec.Cache_v.Cache.Label.) vstd!map.Map<i32./vstd!seq.Seq<u8.>.>.)
(declare-fun lib!exec.Cache_v.Entry./Reserved/addr (lib!exec.Cache_v.Entry.) lib!spec.AsyncDisk_t.Address.)
(declare-fun lib!exec.Cache_v.Entry./Loading/addr (lib!exec.Cache_v.Entry.) lib!spec.AsyncDisk_t.Address.)
(declare-fun lib!exec.Cache_v.Entry./Filled/addr (lib!exec.Cache_v.Entry.) lib!spec.AsyncDisk_t.Address.)
(declare-fun lib!exec.Cache_v.Entry./Filled/data (lib!exec.Cache_v.Entry.) vstd!seq.Seq<u8.>.)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%lib!spec.AsyncDisk_t.Address. Type)
(declare-const TYPE%lib!exec.Cache_v.Status. Type)
(declare-const TYPE%lib!exec.Cache_v.Entry. Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (vstd!map.Map<i32./lib!exec.Cache_v.Entry.>.) Poly)
(declare-fun %Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (Poly) vstd!map.Map<i32./lib!exec.Cache_v.Entry.>.)
(declare-fun Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (vstd!map.Map<i32./lib!exec.Cache_v.Status.>.) Poly)
(declare-fun %Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (Poly) vstd!map.Map<i32./lib!exec.Cache_v.Status.>.)
(declare-fun Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (vstd!map.Map<i32./vstd!seq.Seq<u8.>.>.) Poly)
(declare-fun Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<u8.>. (Poly) vstd!seq.Seq<u8.>.)
(declare-fun Poly%lib!exec.Cache_v.Cache.State. (lib!exec.Cache_v.Cache.State.) Poly)
(declare-fun %Poly%lib!exec.Cache_v.Cache.State. (Poly) lib!exec.Cache_v.Cache.State.)
(declare-fun Poly%lib!exec.Cache_v.Cache.Label. (lib!exec.Cache_v.Cache.Label.) Poly)
(declare-fun %Poly%lib!exec.Cache_v.Cache.Label. (Poly) lib!exec.Cache_v.Cache.Label.)
(declare-fun Poly%lib!spec.AsyncDisk_t.Address. (lib!spec.AsyncDisk_t.Address.) Poly)
(declare-fun %Poly%lib!spec.AsyncDisk_t.Address. (Poly) lib!spec.AsyncDisk_t.Address.)
(declare-fun Poly%lib!exec.Cache_v.Status. (lib!exec.Cache_v.Status.) Poly)
(declare-fun %Poly%lib!exec.Cache_v.Status. (Poly) lib!exec.Cache_v.Status.)
(declare-fun Poly%lib!exec.Cache_v.Entry. (lib!exec.Cache_v.Entry.) Poly)
(declare-fun %Poly%lib!exec.Cache_v.Entry. (Poly) lib!exec.Cache_v.Entry.)
(assert (forall ((x %%Function%%)) (! (= x (%Poly%fun%1. (Poly%fun%1. x))) :pattern ((Poly%fun%1. x)))))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x %%Function%%)) (! (=> (forall ((T%0 Poly)) (! (=> (has_type T%0 T%0&) (has_type (%%apply%%0 x T%0) T%1&)) :pattern ((has_type (%%apply%%0 x T%0) T%1&)))) (has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry.)) (= x (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry.))))))
(assert (forall ((x vstd!map.Map<i32./lib!exec.Cache_v.Entry.>.)) (! (has_type (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. x) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry.)) :pattern ((has_type (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. x) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry.))))))
(assert (forall ((x Poly)) (! (=> (has_type x (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status.)) (= x (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. x)))) :pattern ((has_type x (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status.))))))
(assert (forall ((x vstd!map.Map<i32./lib!exec.Cache_v.Status.>.)) (! (has_type (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. x) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status.)) :pattern ((has_type (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. x) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status.))))))
(assert (forall ((x vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>.)) (! (has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32))) :pattern ((has_type (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. x) (TYPE%vstd!map.Map. $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32)))))))
(assert (forall ((x Poly)) (! (=> (has_type x TYPE%lib!spec.AsyncDisk_t.Address.) (= x (Poly%lib!spec.AsyncDisk_t.Address. (%Poly%lib!spec.AsyncDisk_t.Address. x)))) :pattern ((has_type x TYPE%lib!spec.AsyncDisk_t.Address.)))))
(assert (forall ((x lib!exec.Cache_v.Status.)) (! (= x (%Poly%lib!exec.Cache_v.Status. (Poly%lib!exec.Cache_v.Status. x))) :pattern ((Poly%lib!exec.Cache_v.Status. x)))))
(assert (forall ((x lib!exec.Cache_v.Status.)) (! (has_type (Poly%lib!exec.Cache_v.Status. x) TYPE%lib!exec.Cache_v.Status.) :pattern ((has_type (Poly%lib!exec.Cache_v.Status. x) TYPE%lib!exec.Cache_v.Status.)))))
(assert (forall ((x lib!exec.Cache_v.Entry.)) (! (= x (%Poly%lib!exec.Cache_v.Entry. (Poly%lib!exec.Cache_v.Entry. x))) :pattern ((Poly%lib!exec.Cache_v.Entry. x)))))
(assert (forall ((_addr! lib!spec.AsyncDisk_t.Address.) (_data! vstd!seq.Seq<u8.>.)) (! (=> (has_type (Poly%lib!spec.AsyncDisk_t.Address. _addr!) TYPE%lib!spec.AsyncDisk_t.Address.) (has_type (Poly%lib!exec.Cache_v.Entry. (lib!exec.Cache_v.Entry./Filled _addr! _data!)) TYPE%lib!exec.Cache_v.Entry.)) :pattern ((has_type (Poly%lib!exec.Cache_v.Entry. (lib!exec.Cache_v.Entry./Filled _addr! _data!)) TYPE%lib!exec.Cache_v.Entry.)))))
(assert (forall ((x lib!exec.Cache_v.Entry.)) (! (= (lib!exec.Cache_v.Entry./Filled/addr x) (lib!exec.Cache_v.Entry./Filled/?addr x)) :pattern ((lib!exec.Cache_v.Entry./Filled/addr x)))))
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!pervasive.arbitrary.? (Dcr Type) Poly)
(declare-fun vstd!set.impl&%0.mk_map.? (Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!set.impl&%0.subset_of.? (Dcr Type Poly Poly) Bool)
(declare-fun vstd!map_lib.impl&%0.contains_value.? (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun vstd!map_lib.impl&%0.values.? (Dcr Type Dcr Type Poly) Poly)
(declare-fun vstd!map.impl&%0.new.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun vstd!map_lib.impl&%0.union_prefer_right.? (Dcr Type Dcr Type Poly Poly) Poly)
(declare-fun lib!exec.Cache_v.impl&%1.get_addr.? (Poly) lib!spec.AsyncDisk_t.Address.)
(declare-fun lib!exec.Cache_v.Cache.impl&%5.valid_read.? (Poly Poly Poly) Bool)
(declare-fun lib!exec.Cache_v.Cache.impl&%5.valid_write.? (Poly Poly) Bool)
(declare-fun lib!exec.Cache_v.Cache.impl&%5.inv.? (Poly) Bool)
(declare-fun lib!exec.Cache_v.Cache.impl&%5.access_strong.? (Poly Poly Poly) Bool)
;(declare-fun lib!exec.Cache_v.Cache.impl&%5.inv.? (Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (=> (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self!)))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (key! Poly)) (! (=> (and (has_type self! (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key! K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self! key!) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self! key!)))))
(assert (forall ((A&. Dcr) (A& Type) (F&. Dcr) (F& Type) (f! Poly)) (! (=> (has_type f! F&) (has_type (vstd!set.impl&%0.new.? A&. A& F&. F& f!) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.new.? A&. A& F&. F& f!)))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_new.) (forall ((A&. Dcr) (A& Type) (f! Poly) (a! Poly)) (! (=> (and (has_type f! (TYPE%fun%1. A&. A& $ BOOL)) (has_type a! A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!) (%B (%%apply%%0 (%Poly%fun%1. f!) a!)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f!) a!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_set_ext_equal.) (forall ((A&. Dcr) (A& Type) (s1! Poly) (s2! Poly)) (! (=> (and (has_type s1! (TYPE%vstd!set.Set. A&. A&)) (has_type s2! (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$)))))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1! s2!))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_mk_map_domain.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s! Poly) (f! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. K&. K&)) (has_type f! (TYPE%fun%1. K&. K& V&. V&))) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!)) s!)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!)))))))
(assert (=> (fuel_bool fuel%vstd!set.axiom_mk_map_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s! Poly) (f! Poly) (key! Poly)) (! (=> (and (has_type s! (TYPE%vstd!set.Set. K&. K&)) (has_type f! (TYPE%fun%1. K&. K& V&. V&)) (has_type key! K&)) (=> (vstd!set.impl&%0.contains.? K&. K& s! key!) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!) key!) (%%apply%%0 (%Poly%fun%1. f!) key!)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s! f!) key!))))))
(assert (fuel_bool_default fuel%vstd!set.impl&%0.subset_of.))
(assert (=> (fuel_bool fuel%vstd!set.impl&%0.subset_of.) (forall ((A&. Dcr) (A& Type) (self! Poly) (s2! Poly)) (! (= (vstd!set.impl&%0.subset_of.? A&. A& self! s2!) (forall ((a$ Poly)) (! (=> (has_type a$ A&) (=> (vstd!set.impl&%0.contains.? A&. A& self! a$) (vstd!set.impl&%0.contains.? A&. A& s2! a$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& self! a$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2! a$))))) :pattern ((vstd!set.impl&%0.subset_of.? A&. A& self! s2!))))))
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.contains_value.))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.contains_value.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (v! Poly)) (! (= (vstd!map_lib.impl&%0.contains_value.? K&. K& V&. V& self! v!) (exists ((i$ Poly)) (! (and (has_type i$ K&) (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) i$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& self! i$) v!))) :pattern ((vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) i$))))) :pattern ((vstd!map_lib.impl&%0.contains_value.? K&. K& V&. V& self! v!))))))
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.values.))
(declare-fun %%lambda%%0 (Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (v$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) v$) (B (vstd!map_lib.impl&%0.contains_value.? %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 v$))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4) v$)))))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.values.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly)) (! (= (vstd!map_lib.impl&%0.values.? K&. K& V&. V& self!) (vstd!set.impl&%0.new.? V&. V& $ (TYPE%fun%1. V&. V& $ BOOL) (Poly%fun%1. (mk_fun (%%lambda%%0 K&. K& V&. V& self!))))) :pattern ((vstd!map_lib.impl&%0.values.? K&. K& V&. V& self!))))))
(assert (fuel_bool_default fuel%vstd!map.impl&%0.new.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.new.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk! Poly) (fv! Poly)) (! (= (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!) (vstd!set.impl&%0.mk_map.? K&. K& V&. V& impl%3&. impl%3& (vstd!set.impl&%0.new.? K&. K& impl%2&. impl%2& fk!) fv!)) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!))))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk! Poly) (fv! Poly)) (! (=> (and (has_type fk! impl%2&) (has_type fv! impl%3&)) (has_type (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk! fv!)))))
(assert (fuel_bool_default fuel%vstd!map_lib.impl&%0.union_prefer_right.))
(declare-fun %%lambda%%1 (Dcr Type Poly Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k$) (B (or (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 k$) (vstd!set.impl&%0.contains.? %%hole%%3 %%hole%%4 %%hole%%5 k$)))) :pattern ((%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k$)))))
(declare-fun %%lambda%%2 (Dcr Type Poly Dcr Type Dcr Type Poly Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Dcr) (%%hole%%6 Type) (%%hole%%7 Poly) (%%hole%%8 Dcr) (%%hole%%9 Type) (%%hole%%10 Dcr) (%%hole%%11 Type) (%%hole%%12 Poly) (k$ Poly)) (! (= (%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k$) (ite (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 k$) (vstd!map.impl&%0.index.? %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 k$) (vstd!map.impl&%0.index.? %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 k$))) :pattern ((%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k$)))))
(assert (=> (fuel_bool fuel%vstd!map_lib.impl&%0.union_prefer_right.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self! Poly) (m2! Poly)) (! (= (vstd!map_lib.impl&%0.union_prefer_right.? K&. K& V&. V& self! m2!) (vstd!map.impl&%0.new.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& $ BOOL) $ (TYPE%fun%1. K&. K& V&. V&) (Poly%fun%1. (mk_fun (%%lambda%%1 K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self!) K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!)))) (Poly%fun%1. (mk_fun (%%lambda%%2 K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m2!) K&. K& V&. V& m2! K&. K& V&. V& self!))))) :pattern ((vstd!map_lib.impl&%0.union_prefer_right.? K&. K& V&. V& self! m2!))))))
(declare-fun %%lambda%%4 (Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (slot$ Poly)) (! (= (%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2) slot$) (B (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 slot$))) :pattern ((%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2) slot$)))))
(assert (fuel_bool_default fuel%lib!exec.Cache_v.impl&%1.get_addr.))
(assert (=> (fuel_bool fuel%lib!exec.Cache_v.impl&%1.get_addr.) (forall ((self! Poly)) (! (= (lib!exec.Cache_v.impl&%1.get_addr.? self!) (ite ((_ is lib!exec.Cache_v.Entry./Reserved) (%Poly%lib!exec.Cache_v.Entry. self!)) (let ((addr$ (lib!exec.Cache_v.Entry./Reserved/addr (%Poly%lib!exec.Cache_v.Entry. self!)))) addr$) (ite ((_ is lib!exec.Cache_v.Entry./Loading) (%Poly%lib!exec.Cache_v.Entry. self!)) (let ((addr$ (lib!exec.Cache_v.Entry./Loading/addr (%Poly%lib!exec.Cache_v.Entry. self!)))) addr$) (ite ((_ is lib!exec.Cache_v.Entry./Filled) (%Poly%lib!exec.Cache_v.Entry. self!)) (let ((addr$ (lib!exec.Cache_v.Entry./Filled/addr (%Poly%lib!exec.Cache_v.Entry. self!)))) (let ((data$ (lib!exec.Cache_v.Entry./Filled/data (%Poly%lib!exec.Cache_v.Entry. self!)))) addr$)) (%Poly%lib!spec.AsyncDisk_t.Address. (vstd!pervasive.arbitrary.? $ TYPE%lib!spec.AsyncDisk_t.Address.)))))) :pattern ((lib!exec.Cache_v.impl&%1.get_addr.? self!))))))
(assert (forall ((self! Poly)) (! (=> (has_type self! TYPE%lib!exec.Cache_v.Entry.) (has_type (Poly%lib!spec.AsyncDisk_t.Address. (lib!exec.Cache_v.impl&%1.get_addr.? self!)) TYPE%lib!spec.AsyncDisk_t.Address.)) :pattern ((lib!exec.Cache_v.impl&%1.get_addr.? self!)))))
(declare-fun %%lambda%%12 (Poly) %%Function%%)
(assert (forall ((%%hole%%0 Poly) (slot$ Poly)) (! (= (%%apply%%0 (%%lambda%%12 %%hole%%0) slot$) %%hole%%0) :pattern ((%%apply%%0 (%%lambda%%12 %%hole%%0) slot$)))))
(assert (fuel_bool_default fuel%lib!exec.Cache_v.Cache.impl&%5.valid_write.))
(assert (=> (fuel_bool fuel%lib!exec.Cache_v.Cache.impl&%5.valid_write.) (forall ((self! Poly) (slot! Poly)) (! (= (lib!exec.Cache_v.Cache.impl&%5.valid_write.? self! slot!) (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!)))) slot!) (or ((_ is lib!exec.Cache_v.Entry./Reserved) (%Poly%lib!exec.Cache_v.Entry. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot!))) (and ((_ is lib!exec.Cache_v.Entry./Filled) (%Poly%lib!exec.Cache_v.Entry. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot!))) (not ((_ is lib!exec.Cache_v.Status./Writeback) (%Poly%lib!exec.Cache_v.Status. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot!)))))))) :pattern ((lib!exec.Cache_v.Cache.impl&%5.valid_write.? self! slot!))))))
(declare-fun %%lambda%%13 (Dcr Type Dcr Type Poly Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (%%hole%%5 Dcr) (%%hole%%6 Type) (%%hole%%7 Dcr) (%%hole%%8 Type) (%%hole%%9 Poly) (slot$ Poly)) (! (= (%%apply%%0 (%%lambda%%13 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9) slot$) (Poly%lib!exec.Cache_v.Entry. (lib!exec.Cache_v.Entry./Filled (%Poly%lib!spec.AsyncDisk_t.Address. (Poly%lib!spec.AsyncDisk_t.Address. (lib!exec.Cache_v.impl&%1.get_addr.? (vstd!map.impl&%0.index.? %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 slot$)))) (%Poly%vstd!seq.Seq<u8.>. (vstd!map.impl&%0.index.? %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 slot$))))) :pattern ((%%apply%%0 (%%lambda%%13 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9) slot$)))))
(assert (fuel_bool_default fuel%lib!exec.Cache_v.Cache.impl&%5.inv.))
(assert (=> (fuel_bool fuel%lib!exec.Cache_v.Cache.impl&%5.inv.) (forall ((self! Poly)) (! (= (lib!exec.Cache_v.Cache.impl&%5.inv.? self!) (and (and (and (and (ext_eq false (TYPE%vstd!set.Set. $ (SINT 32)) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))))) (vstd!set.impl&%0.subset_of.? $ (SINT 32) (vstd!map_lib.impl&%0.values.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!)))))) (forall ((slot$ Poly)) (! (=> (has_type slot$ (SINT 32)) (=> (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!)))) slot$) (not ((_ is lib!exec.Cache_v.Entry./Empty) (%Poly%lib!exec.Cache_v.Entry. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot$))))) (and (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) (Poly%lib!spec.AsyncDisk_t.Address. (lib!exec.Cache_v.impl&%1.get_addr.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot$)))) (= (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!))) (Poly%lib!spec.AsyncDisk_t.Address. (lib!exec.Cache_v.impl&%1.get_addr.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot$)))) slot$)))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!)))) slot$))))) (forall ((addr$ Poly)) (! (=> (has_type addr$ TYPE%lib!spec.AsyncDisk_t.Address.) (=> (vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) addr$) (and (not ((_ is lib!exec.Cache_v.Entry./Empty) (%Poly%lib!exec.Cache_v.Entry. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!))) addr$))))) (= (lib!exec.Cache_v.impl&%1.get_addr.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) (vstd!map.impl&%0.index.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!))) addr$))) (%Poly%lib!spec.AsyncDisk_t.Address. addr$))))) :pattern ((vstd!set.impl&%0.contains.? $ TYPE%lib!spec.AsyncDisk_t.Address. (vstd!map.impl&%0.dom.? $ TYPE%lib!spec.AsyncDisk_t.Address. $ (SINT 32) (Poly%vstd!map.Map<lib!spec.AsyncDisk_t.Address./i32.>. (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) addr$))))) (forall ((slot$ Poly)) (! (=> (has_type slot$ (SINT 32)) (=> (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) slot$) (= ((_ is lib!exec.Cache_v.Status./NotFilled) (%Poly%lib!exec.Cache_v.Status. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot$))) (not ((_ is lib!exec.Cache_v.Entry./Filled) (%Poly%lib!exec.Cache_v.Entry. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. self!))) slot$))))))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. self!)))) slot$)))))) :pattern ((lib!exec.Cache_v.Cache.impl&%5.inv.? self!))))))
(declare-fun req%lib!exec.Cache_v.Cache.impl&%5.lemma_msg_inv. (lib!exec.Cache_v.Cache.State.) Bool)
(assert (forall ((s! lib!exec.Cache_v.Cache.State.)) (! (= (req%lib!exec.Cache_v.Cache.impl&%5.lemma_msg_inv. s!) (lib!exec.Cache_v.Cache.impl&%5.inv.? (Poly%lib!exec.Cache_v.Cache.State. s!))) :pattern ((req%lib!exec.Cache_v.Cache.impl&%5.lemma_msg_inv. s!)))))
(declare-fun ens%lib!exec.Cache_v.Cache.impl&%5.lemma_msg_inv. (lib!exec.Cache_v.Cache.State.) Bool)
(assert (fuel_bool_default fuel%lib!exec.Cache_v.Cache.impl&%5.access_strong.))
(assert (=> (fuel_bool fuel%lib!exec.Cache_v.Cache.impl&%5.access_strong.) (forall ((pre! Poly) (post! Poly) (lbl! Poly)) (! (= (lib!exec.Cache_v.Cache.impl&%5.access_strong.? pre! post! lbl!) (let ((update_tmp_lookup_map$ (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. pre!)))) (and ((_ is lib!exec.Cache_v.Cache.Label./Access) (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)) (and (forall ((slot$ Poly)) (! (=> (has_type slot$ (SINT 32)) (=> (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/reads (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)))) slot$) (lib!exec.Cache_v.Cache.impl&%5.valid_read.? pre! slot$ (vstd!map.impl&%0.index.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/reads (%Poly%lib!exec.Cache_v.Cache.Label. lbl!))) slot$)))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/reads (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)))) slot$)))) (and (forall ((slot$ Poly)) (! (=> (has_type slot$ (SINT 32)) (=> (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/writes (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)))) slot$) (lib!exec.Cache_v.Cache.impl&%5.valid_write.? pre! slot$))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/writes (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)))) slot$)))) (and (let ((updated_entries$ (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (vstd!map.impl&%0.new.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. $ (TYPE%fun%1. $ (SINT 32) $ BOOL) $ (TYPE%fun%1. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry.) (Poly%fun%1. (mk_fun (%%lambda%%4 $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/writes (%Poly%lib!exec.Cache_v.Cache.Label. lbl!))))))) (Poly%fun%1. (mk_fun (%%lambda%%13 $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. pre!))) $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/writes (%Poly%lib!exec.Cache_v.Cache.Label. lbl!)))))))))) (let ((updated_status_map$ (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (vstd!map.impl&%0.new.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. $ (TYPE%fun%1. $ (SINT 32) $ BOOL) $ (TYPE%fun%1. $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status.) (Poly%fun%1. (mk_fun (%%lambda%%4 $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ (TYPE%vstd!seq.Seq. $ (UINT 8)) (Poly%vstd!map.Map<i32./vstd!seq.Seq<u8.>.>. (lib!exec.Cache_v.Cache.Label./Access/writes (%Poly%lib!exec.Cache_v.Cache.Label. lbl!))))))) (Poly%fun%1. (mk_fun (%%lambda%%12 (Poly%lib!exec.Cache_v.Status. lib!exec.Cache_v.Status./Dirty)))))))) (let ((update_tmp_entries$ (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (vstd!map_lib.impl&%0.union_prefer_right.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Entry. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. pre!))) (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Entry.>. updated_entries$))))) (let ((update_tmp_status_map$ (%Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (vstd!map_lib.impl&%0.union_prefer_right.? $ (SINT 32) $ TYPE%lib!exec.Cache_v.Status. (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. pre!))) (Poly%vstd!map.Map<i32./lib!exec.Cache_v.Status.>. updated_status_map$))))) (and (= (lib!exec.Cache_v.Cache.State./State/status_map (%Poly%lib!exec.Cache_v.Cache.State. post!)) update_tmp_status_map$) (= (lib!exec.Cache_v.Cache.State./State/entries (%Poly%lib!exec.Cache_v.Cache.State. post!)) update_tmp_entries$)))))) (= (lib!exec.Cache_v.Cache.State./State/lookup_map (%Poly%lib!exec.Cache_v.Cache.State. post!)) update_tmp_lookup_map$))))))) :pattern ((lib!exec.Cache_v.Cache.impl&%5.access_strong.? pre! post! lbl!))))))
(declare-const pre! lib!exec.Cache_v.Cache.State.)
(declare-const post! lib!exec.Cache_v.Cache.State.)
(declare-const lbl! lib!exec.Cache_v.Cache.Label.)
(assert fuel_defaults)
(assert (and (lib!exec.Cache_v.Cache.impl&%5.inv.? (Poly%lib!exec.Cache_v.Cache.State. pre!)) (lib!exec.Cache_v.Cache.impl&%5.access_strong.? (Poly%lib!exec.Cache_v.Cache.State. pre!) (Poly%lib!exec.Cache_v.Cache.State. post!) (Poly%lib!exec.Cache_v.Cache.Label. lbl!))))
(declare-const %%location_label%%0 Bool)
(declare-const %%location_label%%1 Bool)
(assert (not (lib!exec.Cache_v.Cache.impl&%5.inv.? (Poly%lib!exec.Cache_v.Cache.State. post!))))
(check-sat)
