(declare-sort %% 0)
(declare-sort P 0)
(declare-fun B () P)
(declare-fun % (P) Bool)
(declare-sort T 0)
(declare-const O T)
(declare-sort D 0)
(declare-const $ D)
(declare-fun a (P T) Bool)
(declare-sort vs 0)
(declare-datatypes ((lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint 0) (lib!delega 0) (lib!delegation_map_v.DelegationMap. 0) (lib!abstract_end_point_t.AbstractEndPoint. 0) (lib!delegation_map_t.AbstractDelegationMap. 0) (lib!io_t.EndPoint. 0) (lib!keys_t.KeyRange. 0)) (((lib!delegation_map_v.StrictlyOrderedVec./StrictlyOrderedVec)) ((lib!delegation_map_v.StrictlyOrderedMap./StrictlyOrderedMap)) ((lib!delegation_map_v.DelegationMap./DelegationMap)) ((lib!abstract_end_point_t.AbstractEndPoint./AbstractEndPoint)) ((lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap (lib!delegation_map_t.AbstractDelegationMap./AbstractDelegationMap/?0 vs))) ((lib!io_t.EndPoint./EndPoint)) ((lib!keys_t.KeyRange./KeyRange))))
(declare-datatypes ((c 0) (lib 0)) (((core!option.Option./Some)) ((lib/k (lib/k/?k c)))))
(declare-fun b (lib!delegation_map_t.AbstractDelegationMap.) vs)
(declare-fun i (lib!keys_t.KeyRange.) lib)
(declare-fun T (T) T)
(declare-const TY T)
(declare-const Y T)
(declare-fun P (%%) P)
(declare-fun %P (P) %%)
(declare-fun Poly (vs) P)
(declare-fun %Pol (P) vs)
(declare-fun y (lib!delegation_map_v.DelegationMap.) P)
(declare-fun ly (lib!abstract_end_point_t.AbstractEndPoint.) P)
(declare-fun oly (lib!delegation_map_t.AbstractDelegationMap.) P)
(declare-fun Po (P) lib!delegation_map_t.AbstractDelegationMap.)
(declare-fun o () P)
(declare-fun ol (lib) P)
(declare-fun Pol () P)
(declare-fun %Po () lib!keys_t.KeyRange.)
(declare-fun %% (%% P) P)
(declare-fun v (D T D T P) P)
(declare-fun s (D T P P) Bool)
(declare-fun vs (D T D T P P) P)
(declare-fun td () P)
(declare-fun t () P)
(declare-fun li (P) lib!abstract_end_point_t.AbstractEndPoint.)
(declare-fun st (P P) P)
(declare-fun b! (P P) Bool)
(declare-fun ib (D T P) lib)
(declare-fun lib (P P) Bool)
(declare-fun vst (D T D T P P) P)
(declare-fun %%l (D T P D T D T P D T D T P) %%)
(declare-fun la () %%)
(declare-fun %l (P) %%)
(declare-const l lib)
(declare-fun po () lib)
(declare-const t1 P)
(assert (forall ((k P)) (! (not (b! k (ol po))) :pattern ((b! k (ol l))))))
(assert (b! t1 (ol (i %Po))))
(check-sat)
